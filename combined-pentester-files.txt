===== src\pentester\controllers\pentester.controller.ts =====
// src/pentester/controllers/pentester.controller.ts

import { Controller, Get, Put, Body, UseGuards, HttpCode, HttpStatus, Req } from '@nestjs/common';
import type { Request } from 'express';
import type { User } from '@prisma/client';
import { UserRole } from '@prisma/client';
import { PentesterService } from '../services/pentester.service';
import { AuthGuard } from '@auth/guards/auth.guard';
import { RolesGuard } from '@auth/guards/roles.guard';
import { Roles } from '@auth/decorators/roles.decorator';
import { CurrentUser } from '@auth/decorators/current-user.decorator';
import { ResponseBuilder } from '@common/utils/response-builder.util';
import { UpdatePentesterProfileDto } from '../dto/update-profile.dto';

@Controller('pentester')
@UseGuards(AuthGuard, RolesGuard)
@Roles(UserRole.PENTESTER, UserRole.R_ADMIN)
export class PentesterController {
    constructor(
        private readonly pentesterService: PentesterService,
        private readonly responseBuilder: ResponseBuilder,
    ) { }

    @Get('profile')
    @HttpCode(HttpStatus.OK)
    async getProfile(@CurrentUser() user: User, @Req() req: Request) {
        const profile = await this.pentesterService.getProfile(user.id);
        return this.responseBuilder.success(profile, undefined, req.url);
    }

    @Get('profile/stats')
    @HttpCode(HttpStatus.OK)
    async getProfileStats(@CurrentUser() user: User, @Req() req: Request) {
        const stats = await this.pentesterService.getProfileStats(user.id);
        return this.responseBuilder.success(stats, undefined, req.url);
    }

    @Put('profile')
    @HttpCode(HttpStatus.OK)
    async updateProfile(
        @CurrentUser() user: User,
        @Body() dto: UpdatePentesterProfileDto,
        @Req() req: Request,
    ) {
        const profile = await this.pentesterService.updateProfile(user.id, dto);
        return this.responseBuilder.success(profile, 'Profile updated successfully', req.url);
    }

    @Get('dashboard')
    @HttpCode(HttpStatus.OK)
    async getDashboard(@CurrentUser() user: User, @Req() req: Request) {
        const dashboard = await this.pentesterService.getDashboard(user.id);
        return this.responseBuilder.success(dashboard, undefined, req.url);
    }
}


===== src\pentester\controllers\pentester-projects.controller.ts =====

// src/pentester/controllers/pentester-projects.controller.ts

import { Controller, Get, Patch, Param, Query, Body, UseGuards, HttpCode, HttpStatus, Req } from '@nestjs/common';
import type { Request } from 'express';
import type { User } from '@prisma/client';
import { UserRole } from '@prisma/client';
import { PentesterProjectsService } from '../services/pentester-projects.service';
import { AuthGuard } from '@auth/guards/auth.guard';
import { RolesGuard } from '@auth/guards/roles.guard';
import { Roles } from '@auth/decorators/roles.decorator';
import { CurrentUser } from '@auth/decorators/current-user.decorator';
import { ResponseBuilder } from '@common/utils/response-builder.util';
import { PentesterProjectQueryDto } from '../dto/pentester-query.dto';
import { UpdateProjectStatusDto } from '../dto/submit-report.dto';

@Controller('pentester/projects')
@UseGuards(AuthGuard, RolesGuard)
@Roles(UserRole.PENTESTER, UserRole.R_ADMIN)
export class PentesterProjectsController {
    constructor(
        private readonly pentesterProjectsService: PentesterProjectsService,
        private readonly responseBuilder: ResponseBuilder,
    ) { }

    @Get()
    @HttpCode(HttpStatus.OK)
    async findAll(
        @CurrentUser() user: User,
        @Query() query: PentesterProjectQueryDto,
        @Req() req: Request,
    ) {
        const result = await this.pentesterProjectsService.findAll(user.id, query);
        return this.responseBuilder.success({ stats: result.stats, data: result.data }, undefined, req.url);
    }

    @Get('available-for-upload')
    @HttpCode(HttpStatus.OK)
    async getAvailableForUpload(@CurrentUser() user: User, @Req() req: Request) {
        const projects = await this.pentesterProjectsService.getAvailableForUpload(user.id);
        return this.responseBuilder.success(projects, undefined, req.url);
    }

    @Get(':id')
    @HttpCode(HttpStatus.OK)
    async findOne(@CurrentUser() user: User, @Param('id') id: string, @Req() req: Request) {
        const project = await this.pentesterProjectsService.findOne(user.id, id);
        return this.responseBuilder.success(project, undefined, req.url);
    }

    @Patch(':id/status')
    @HttpCode(HttpStatus.OK)
    async updateStatus(
        @CurrentUser() user: User,
        @Param('id') id: string,
        @Body() dto: UpdateProjectStatusDto,
        @Req() req: Request,
    ) {
        const result = await this.pentesterProjectsService.updateProjectStatus(user.id, id, dto);
        return this.responseBuilder.success(result, result.message, req.url);
    }
}


===== src\pentester\controllers\pentester-reports.controller.ts =====
// src/pentester/controllers/pentester-reports.controller.ts

import { Controller, Get, Post, Param, Query, Body, UseInterceptors, UploadedFile, UseGuards, HttpCode, HttpStatus, Req } from '@nestjs/common';
import { FileInterceptor } from '@nestjs/platform-express';
import type { Request } from 'express';
import type { User } from '@prisma/client';
import { UserRole } from '@prisma/client';
import { PentesterReportsService } from '../services/pentester-reports.service';
import { AuthGuard } from '@auth/guards/auth.guard';
import { RolesGuard } from '@auth/guards/roles.guard';
import { Roles } from '@auth/decorators/roles.decorator';
import { CurrentUser } from '@auth/decorators/current-user.decorator';
import { ResponseBuilder } from '@common/utils/response-builder.util';
import { PentesterReportQueryDto } from '../dto/pentester-query.dto';
import { SubmitReportDto } from '../dto/submit-report.dto';

@Controller('pentester/reports')
@UseGuards(AuthGuard, RolesGuard)
@Roles(UserRole.PENTESTER, UserRole.R_ADMIN)
export class PentesterReportsController {
    constructor(
        private readonly pentesterReportsService: PentesterReportsService,
        private readonly responseBuilder: ResponseBuilder,
    ) { }

    @Get()
    @HttpCode(HttpStatus.OK)
    async findAll(
        @CurrentUser() user: User,
        @Query() query: PentesterReportQueryDto,
        @Req() req: Request,
    ) {
        const result = await this.pentesterReportsService.findAll(user.id, query);
        return this.responseBuilder.success({ stats: result.stats, data: result.data }, undefined, req.url);
    }

    @Get(':id')
    @HttpCode(HttpStatus.OK)
    async findOne(@CurrentUser() user: User, @Param('id') id: string, @Req() req: Request) {
        const report = await this.pentesterReportsService.findOne(user.id, id);
        return this.responseBuilder.success(report, undefined, req.url);
    }

    @Get(':id/details')
    @HttpCode(HttpStatus.OK)
    async findDetails(@CurrentUser() user: User, @Param('id') id: string, @Req() req: Request) {
        const details = await this.pentesterReportsService.findDetails(user.id, id);
        return this.responseBuilder.success(details, undefined, req.url);
    }

    @Post()
    @UseInterceptors(FileInterceptor('reportFile'))
    @HttpCode(HttpStatus.CREATED)
    async submitReport(
        @CurrentUser() user: User,
        @Body() dto: SubmitReportDto,
        @UploadedFile() file: Express.Multer.File,
        @Req() req: Request,
    ) {
        const result = await this.pentesterReportsService.submitReport(user.id, dto, file);
        return this.responseBuilder.success(result, result.message, req.url);
    }
}


===== src\pentester\services\pentester.service.ts =====
// src/pentester/services/pentester.service.ts

import { Injectable, NotFoundException } from '@nestjs/common';
import { PentesterRepository } from '../repositories/pentester.repository';
import { ErrorCodes } from '@common/enums/error-codes.enum';
import { UpdatePentesterProfileDto } from '../dto/update-profile.dto';
import {
    PentesterProfileResponse,
    PentesterProfileStats,
    PentesterDashboardResponse,
} from '../types/pentester-response.types';

@Injectable()
export class PentesterService {
    constructor(private readonly pentesterRepository: PentesterRepository) { }

    async getProfile(userId: string): Promise<PentesterProfileResponse> {
        const pentester = await this.pentesterRepository.findPentesterByUserId(userId);

        if (!pentester) {
            throw new NotFoundException({
                code: ErrorCodes.USER_NOT_FOUND,
                message: 'Pentester profile not found',
            });
        }

        return {
            id: pentester.id,
            firstName: pentester.user.firstName,
            lastName: pentester.user.lastName,
            email: pentester.user.email,
            phone: pentester.user.phone,
            specialization: pentester.specialization,
            location: pentester.location,
            bio: pentester.bio || '',
            memberSince: pentester.memberSince.toISOString(),
            status: pentester.user.status,
        };
    }

    async getProfileStats(userId: string): Promise<PentesterProfileStats> {
        return this.pentesterRepository.getProfileStats(userId);
    }

    async updateProfile(userId: string, dto: UpdatePentesterProfileDto): Promise<PentesterProfileResponse> {
        const pentester = await this.pentesterRepository.findPentesterByUserId(userId);

        if (!pentester) {
            throw new NotFoundException({
                code: ErrorCodes.USER_NOT_FOUND,
                message: 'Pentester profile not found',
            });
        }

        const updated = await this.pentesterRepository.updatePentesterProfile(userId, dto);

        return {
            id: updated.id,
            firstName: updated.user.firstName,
            lastName: updated.user.lastName,
            email: updated.user.email,
            phone: updated.user.phone,
            specialization: updated.specialization,
            location: updated.location,
            bio: updated.bio || '',
            memberSince: updated.memberSince.toISOString(),
            status: updated.user.status,
        };
    }

    async getDashboard(userId: string): Promise<PentesterDashboardResponse> {
        const [stats, upcomingDeadlinesData, myProjectsData, recentActivitiesData] = await Promise.all([
            this.pentesterRepository.getDashboardStats(userId),
            this.pentesterRepository.getUpcomingDeadlines(userId),
            this.pentesterRepository.getMyProjects(userId),
            this.pentesterRepository.getRecentActivities(userId),
        ]);

        const upcomingDeadlines = upcomingDeadlinesData.map((project) => ({
            id: project.id,
            projectName: project.name,
            client: project.client.companyName,
            daysLeft: this.calculateDaysLeft(project.deadline),
            status: this.mapStatusToFrontend(project.status),
        }));

        const myProjects = myProjectsData.map((project) => ({
            id: project.id,
            name: project.name,
            client: project.client.companyName,
            service: project.serviceCategory?.name || 'N/A',
            status: this.mapStatusToFrontend(project.status),
            deadline: project.deadline?.toISOString() || '',
            daysLeft: this.calculateDaysLeft(project.deadline),
        }));

        const recentActivities = recentActivitiesData.map((activity) => ({
            id: activity.id,
            type: activity.activityType.toLowerCase(),
            message: activity.description,
            time: this.getRelativeTime(activity.createdAt),
            status: this.mapActivityStatus(activity.activityType),
        }));

        return {
            stats,
            upcomingDeadlines,
            myProjects,
            recentActivities,
        };
    }

    private calculateDaysLeft(deadline: Date | null): number {
        if (!deadline) return 0;
        const now = new Date();
        const diff = deadline.getTime() - now.getTime();
        return Math.ceil(diff / (1000 * 60 * 60 * 24));
    }

    private mapStatusToFrontend(status: string): string {
        const statusMap: Record<string, string> = {
            NOT_STARTED: 'Not Started',
            IN_PROGRESS: 'In Progress',
            TESTING_COMPLETE: 'Testing Complete',
            REPORT_SUBMITTED: 'Report Submitted',
            UNDER_REVIEW: 'Under Review',
            COMPLETED: 'Completed',
            REJECTED: 'Rejected',
        };
        return statusMap[status] || status;
    }

    private mapActivityStatus(activityType: string): string {
        const statusMap: Record<string, string> = {
            CREATED: 'info',
            STATUS_CHANGED: 'info',
            REPORT_SUBMITTED: 'success',
            REPORT_APPROVED: 'success',
            REPORT_REJECTED: 'error',
        };
        return statusMap[activityType] || 'info';
    }

    private getRelativeTime(date: Date): string {
        const now = new Date();
        const diffMs = now.getTime() - date.getTime();
        const diffMins = Math.floor(diffMs / (1000 * 60));
        const diffHours = Math.floor(diffMs / (1000 * 60 * 60));
        const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));

        if (diffMins < 1) return 'Just now';
        if (diffMins < 60) return `${diffMins} minute${diffMins > 1 ? 's' : ''} ago`;
        if (diffHours < 24) return `${diffHours} hour${diffHours > 1 ? 's' : ''} ago`;
        return `${diffDays} day${diffDays > 1 ? 's' : ''} ago`;
    }
}


===== src\pentester\services\pentester-projects.service.ts =====
// src/pentester/services/pentester-projects.service.ts

import { Injectable, NotFoundException, BadRequestException } from '@nestjs/common';
import { PentesterProjectsRepository } from '../repositories/pentester-projects.repository';
import { PentesterRepository } from '../repositories/pentester.repository';
import { ErrorCodes } from '@common/enums/error-codes.enum';
import { PentesterProjectQueryDto } from '../dto/pentester-query.dto';
import { UpdateProjectStatusDto } from '../dto/submit-report.dto';
import { ProjectStatus } from '@prisma/client';

@Injectable()
export class PentesterProjectsService {
    constructor(
        private readonly pentesterProjectsRepository: PentesterProjectsRepository,
        private readonly pentesterRepository: PentesterRepository,
    ) { }

    async findAll(userId: string, query: PentesterProjectQueryDto) {
        const { page = 1, limit = 10, search, status, service } = query;

        const [{ projects, total }, stats] = await Promise.all([
            this.pentesterProjectsRepository.findAllProjects({
                pentesterId: userId,
                page,
                limit,
                search,
                status,
                service,
            }),
            this.pentesterProjectsRepository.getProjectsStats(userId),
        ]);

        const data = projects.map((project) => ({
            id: project.id,
            name: project.name,
            client: project.client.companyName,
            company: project.client.companyName,
            service: project.serviceCategory?.name || 'N/A',
            status: this.mapStatusToFrontend(project.status),
            priority: this.mapPriorityToFrontend(project.priority),
            startDate: project.startDate?.toISOString() || '',
            endDate: project.endDate?.toISOString() || '',
            daysLeft: this.calculateDaysLeft(project.deadline || project.endDate),
            scope: project.scopeOfWork || '',
            objectives: project.objectives || '',
        }));

        return {
            stats,
            data,
            pagination: {
                page,
                limit,
                total,
                totalPages: Math.ceil(total / limit),
                hasNextPage: page < Math.ceil(total / limit),
                hasPreviousPage: page > 1,
            },
        };
    }

    async findOne(userId: string, projectId: string) {
        const project = await this.pentesterProjectsRepository.findProjectById(projectId, userId);

        if (!project) {
            throw new NotFoundException({
                code: ErrorCodes.NOT_FOUND,
                message: 'Project not found',
            });
        }

        return {
            id: project.id,
            name: project.name,
            client: project.client.companyName,
            company: project.client.companyName,
            email: project.client.user.email,
            phone: project.client.user.phone,
            address: project.client.address,
            service: project.serviceCategory?.name || 'N/A',
            status: this.mapStatusToFrontend(project.status),
            priority: this.mapPriorityToFrontend(project.priority),
            startDate: project.startDate?.toISOString() || '',
            endDate: project.endDate?.toISOString() || '',
            daysLeft: this.calculateDaysLeft(project.deadline || project.endDate),
            scope: project.scopeOfWork || '',
            objectives: project.objectives || '',
            targetUrls: project.targetUrls || '',
            createdBy: project.radmin ? `${project.radmin.firstName} ${project.radmin.lastName}` : 'Unknown',
            createdAt: project.createdAt.toISOString(),
        };
    }

    async updateProjectStatus(userId: string, projectId: string, dto: UpdateProjectStatusDto) {
        const project = await this.pentesterProjectsRepository.findProjectById(projectId, userId);

        if (!project) {
            throw new NotFoundException({
                code: ErrorCodes.NOT_FOUND,
                message: 'Project not found',
            });
        }

        const validStatuses = ['NOT_STARTED', 'IN_PROGRESS', 'TESTING_COMPLETE'];
        if (!validStatuses.includes(dto.status)) {
            throw new BadRequestException({
                code: 'INVALID_STATUS',
                message: 'Invalid project status',
            });
        }

        await this.pentesterProjectsRepository.updateProjectStatus(projectId, userId, dto.status as ProjectStatus);

        return { message: 'Project status updated successfully' };
    }

    async getAvailableForUpload(userId: string) {
        const projects = await this.pentesterProjectsRepository.getAvailableProjectsForUpload(userId);

        return projects.map((project) => ({
            id: project.id,
            name: project.name,
            status: this.mapStatusToFrontend(project.status),
            clientName: project.client.companyName,
            serviceName: project.serviceCategory?.name || 'N/A',
            projectName: project.name,
        }));
    }

    private calculateDaysLeft(date: Date | null): number {
        if (!date) return 0;
        const now = new Date();
        const diff = date.getTime() - now.getTime();
        return Math.ceil(diff / (1000 * 60 * 60 * 24));
    }

    private mapStatusToFrontend(status: string): string {
        const statusMap: Record<string, string> = {
            NOT_STARTED: 'Not Started',
            IN_PROGRESS: 'In Progress',
            TESTING_COMPLETE: 'Testing Complete',
            REPORT_SUBMITTED: 'Report Submitted',
            UNDER_REVIEW: 'Under Review',
            COMPLETED: 'Completed',
            REJECTED: 'Rejected',
        };
        return statusMap[status] || status;
    }

    private mapPriorityToFrontend(priority: string): string {
        return priority.toLowerCase();
    }
}


===== src\pentester\services\pentester-reports.service.ts =====
// src/pentester/services/pentester-reports.service.ts

import { Injectable, NotFoundException, BadRequestException } from '@nestjs/common';
import { PentesterReportsRepository } from '../repositories/pentester-reports.repository';
import { PentesterRepository } from '../repositories/pentester.repository';
import { ErrorCodes } from '@common/enums/error-codes.enum';
import { PentesterReportQueryDto } from '../dto/pentester-query.dto';
import { SubmitReportDto, ResubmitReportDto } from '../dto/submit-report.dto';

@Injectable()
export class PentesterReportsService {
    constructor(
        private readonly pentesterReportsRepository: PentesterReportsRepository,
        private readonly pentesterRepository: PentesterRepository,
    ) { }

    async findAll(userId: string, query: PentesterReportQueryDto) {
        const { page = 1, limit = 10, search, status } = query;

        const [{ reports, total }, stats] = await Promise.all([
            this.pentesterReportsRepository.findAllReports({
                pentesterId: userId,
                page,
                limit,
                search,
                status,
            }),
            this.pentesterReportsRepository.getReportsStats(userId),
        ]);

        const data = reports.map((report) => ({
            id: report.id,
            projectName: report.project.name,
            projectId: report.project.id,
            client: report.project.client.companyName,
            service: report.project.serviceCategory?.name || 'N/A',
            version: report.version,
            status: this.mapStatusToFrontend(report.status),
            submittedDate: report.submittedAt.toISOString(),
            reviewedDate: report.reviewedAt?.toISOString() || null,
            reviewedBy: report.reviewer ? `${report.reviewer.firstName} ${report.reviewer.lastName}` : null,
            reviewerEmail: report.reviewer?.email || null,
            rejectionReason: report.rejectionReason,
            fileName: report.fileName,
            fileSize: this.formatFileSize(report.fileSize),
            fileUrl: report.fileUrl,
            submissionNotes: report.submissionNotes,
        }));

        return {
            stats,
            data,
            pagination: {
                page,
                limit,
                total,
                totalPages: Math.ceil(total / limit),
                hasNextPage: page < Math.ceil(total / limit),
                hasPreviousPage: page > 1,
            },
        };
    }

    async findOne(userId: string, reportId: string) {
        const report = await this.pentesterReportsRepository.findReportById(reportId, userId);

        if (!report) {
            throw new NotFoundException({
                code: ErrorCodes.NOT_FOUND,
                message: 'Report not found',
            });
        }

        return {
            id: report.id,
            projectName: report.project.name,
            projectId: report.project.id,
            client: report.project.client.companyName,
            service: report.project.serviceCategory?.name || 'N/A',
            version: report.version,
            status: this.mapStatusToFrontend(report.status),
            submittedDate: report.submittedAt.toISOString(),
            reviewedDate: report.reviewedAt?.toISOString() || null,
            reviewedBy: report.reviewer ? `${report.reviewer.firstName} ${report.reviewer.lastName}` : null,
            reviewerEmail: report.reviewer?.email || null,
            rejectionReason: report.rejectionReason,
            fileName: report.fileName,
            fileSize: this.formatFileSize(report.fileSize),
            fileUrl: report.fileUrl,
            submissionNotes: report.submissionNotes,
        };
    }

    async findDetails(userId: string, reportId: string) {
        const report = await this.pentesterReportsRepository.findReportDetails(reportId, userId);

        if (!report) {
            throw new NotFoundException({
                code: ErrorCodes.NOT_FOUND,
                message: 'Report not found',
            });
        }

        const checksCompleted = report.checks.map((check) => ({
            id: check.id,
            name: check.securityCheck.title,
            completed: check.completed,
        }));

        const history = report.history.map((h) => ({
            id: h.id,
            version: h.version,
            status: this.mapStatusToFrontend(h.status),
            submittedDate: h.submittedDate.toISOString(),
            reviewedDate: h.reviewedDate?.toISOString() || '',
            fileName: h.fileName,
            fileUrl: h.fileUrl,
            rejectionReason: h.rejectionReason,
        }));

        return {
            id: report.id,
            projectName: report.project.name,
            projectId: report.project.id,
            client: report.project.client.companyName,
            service: report.project.serviceCategory?.name || 'N/A',
            version: report.version,
            status: this.mapStatusToFrontend(report.status),
            submittedDate: report.submittedAt.toISOString(),
            reviewedDate: report.reviewedAt?.toISOString() || null,
            reviewedBy: report.reviewer ? `${report.reviewer.firstName} ${report.reviewer.lastName}` : null,
            reviewerEmail: report.reviewer?.email || null,
            rejectionReason: report.rejectionReason,
            fileName: report.fileName,
            fileSize: this.formatFileSize(report.fileSize),
            fileUrl: report.fileUrl,
            submissionNotes: report.submissionNotes,
            checksCompleted,
            history,
        };
    }

    async submitReport(userId: string, dto: SubmitReportDto, file: Express.Multer.File) {
        const latestVersion = await this.pentesterReportsRepository.getLatestReportVersion(dto.projectId);
        const newVersion = latestVersion + 1;

        const report = await this.pentesterReportsRepository.createReport({
            projectId: dto.projectId,
            pentesterId: userId,
            fileName: file.filename,
            fileUrl: `/uploads/reports/${file.filename}`,
            fileSize: file.size,
            fileType: file.mimetype,
            submissionNotes: dto.submissionNotes,
            version: newVersion,
        });

        const checks = {
            executiveSummary: dto.executiveSummary,
            vulnerabilityDetails: dto.vulnerabilityDetails,
            riskRatings: dto.riskRatings,
            remediationSteps: dto.remediationSteps,
            evidenceAttached: dto.evidenceAttached,
        };

        await this.pentesterReportsRepository.createReportChecks(report.id, checks);

        return {
            id: report.id,
            version: report.version,
            message: 'Report submitted successfully',
        };
    }

    private mapStatusToFrontend(status: string): string {
        const statusMap: Record<string, string> = {
            PENDING: 'Under Review',
            UNDER_REVIEW: 'Under Review',
            APPROVED: 'Approved',
            REJECTED: 'Rejected',
            RESUBMITTED: 'Under Review',
        };
        return statusMap[status] || status;
    }

    private formatFileSize(bytes: number): string {
        if (bytes < 1024) return `${bytes} B`;
        if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(2)} KB`;
        return `${(bytes / (1024 * 1024)).toFixed(2)} MB`;
    }
}


===== src\pentester\repositories\pentester.repository.ts =====
// src/pentester/repositories/pentester.repository.ts

import { Injectable } from '@nestjs/common';
import { PrismaService } from '@core/database/prisma.service';

@Injectable()
export class PentesterRepository {
    constructor(private readonly prisma: PrismaService) { }

    async findPentesterByUserId(userId: string) {
        return this.prisma.pentester.findUnique({
            where: { userId },
            include: {
                user: {
                    select: {
                        id: true,
                        email: true,
                        firstName: true,
                        lastName: true,
                        phone: true,
                        status: true,
                    },
                },
            },
        });
    }

    async updatePentesterProfile(userId: string, data: any) {
        return this.prisma.$transaction(async (tx) => {
            await tx.user.update({
                where: { id: userId },
                data: {
                    firstName: data.firstName,
                    lastName: data.lastName,
                    phone: data.phone,
                },
            });

            return tx.pentester.update({
                where: { userId },
                data: {
                    specialization: data.specialization,
                    location: data.location,
                    bio: data.bio,
                },
                include: {
                    user: true,
                },
            });
        });
    }

    async getDashboardStats(userId: string) {
        const [activeProjects, upcomingDeadlines, underReview, rejected] = await Promise.all([
            this.prisma.project.count({
                where: {
                    pentesterId: userId,
                    status: { in: ['NOT_STARTED', 'IN_PROGRESS', 'TESTING_COMPLETE'] },
                    deletedAt: null,
                },
            }),
            this.prisma.project.count({
                where: {
                    pentesterId: userId,
                    deadline: { lte: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000) },
                    status: { notIn: ['COMPLETED', 'REJECTED'] },
                    deletedAt: null,
                },
            }),
            this.prisma.report.count({
                where: {
                    pentesterId: userId,
                    status: 'UNDER_REVIEW',
                },
            }),
            this.prisma.report.count({
                where: {
                    pentesterId: userId,
                    status: 'REJECTED',
                },
            }),
        ]);

        return { activeProjects, upcomingDeadlines, underReview, rejected };
    }

    async getUpcomingDeadlines(userId: string, limit: number = 5) {
        return this.prisma.project.findMany({
            where: {
                pentesterId: userId,
                deadline: { lte: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000) },
                status: { notIn: ['COMPLETED', 'REJECTED'] },
                deletedAt: null,
            },
            take: limit,
            orderBy: { deadline: 'asc' },
            include: {
                client: { select: { companyName: true } },
            },
        });
    }

    async getMyProjects(userId: string, limit: number = 5) {
        return this.prisma.project.findMany({
            where: {
                pentesterId: userId,
                deletedAt: null,
            },
            take: limit,
            orderBy: { updatedAt: 'desc' },
            include: {
                client: { select: { companyName: true } },
                serviceCategory: { select: { name: true } },
            },
        });
    }

    async getRecentActivities(userId: string, limit: number = 10) {
        return this.prisma.projectActivity.findMany({
            where: { userId },
            take: limit,
            orderBy: { createdAt: 'desc' },
            include: {
                project: {
                    select: {
                        name: true,
                        client: { select: { companyName: true } },
                    },
                },
            },
        });
    }

    async getProfileStats(userId: string) {
        const [totalProjects, completedProjects, inProgressProjects] = await Promise.all([
            this.prisma.project.count({
                where: { pentesterId: userId, deletedAt: null },
            }),
            this.prisma.project.count({
                where: { pentesterId: userId, status: 'COMPLETED', deletedAt: null },
            }),
            this.prisma.project.count({
                where: {
                    pentesterId: userId,
                    status: { in: ['NOT_STARTED', 'IN_PROGRESS', 'TESTING_COMPLETE'] },
                    deletedAt: null,
                },
            }),
        ]);

        const successRate = totalProjects > 0 ? Math.round((completedProjects / totalProjects) * 100) : 0;

        return {
            totalProjects,
            completedProjects,
            inProgressProjects,
            successRate: `${successRate}%`,
        };
    }
}


===== src\pentester\repositories\pentester-projects.repository.ts =====
// src/pentester/repositories/pentester-projects.repository.ts

import { Injectable } from '@nestjs/common';
import { PrismaService } from '@core/database/prisma.service';
import { ProjectStatus } from '@prisma/client';

@Injectable()
export class PentesterProjectsRepository {
    constructor(private readonly prisma: PrismaService) { }

    async findAllProjects(params: {
        pentesterId: string;
        page: number;
        limit: number;
        search?: string;
        status?: string;
        service?: string;
    }) {
        const { pentesterId, page, limit, search, status, service } = params;
        const skip = (page - 1) * limit;

        const where: any = {
            pentesterId,
            deletedAt: null,
        };

        if (search) {
            where.OR = [
                { name: { contains: search, mode: 'insensitive' } },
                { description: { contains: search, mode: 'insensitive' } },
            ];
        }

        if (status && status !== 'all') {
            where.status = status as ProjectStatus;
        }

        if (service && service !== 'all') {
            where.serviceCategory = { name: service };
        }

        const [projects, total] = await Promise.all([
            this.prisma.project.findMany({
                where,
                skip,
                take: limit,
                orderBy: { updatedAt: 'desc' },
                include: {
                    client: {
                        select: {
                            companyName: true,
                            address: true,
                        },
                    },
                    serviceCategory: {
                        select: { name: true },
                    },
                },
            }),
            this.prisma.project.count({ where }),
        ]);

        return { projects, total };
    }

    async findProjectById(projectId: string, pentesterId: string) {
        return this.prisma.project.findFirst({
            where: {
                id: projectId,
                pentesterId,
                deletedAt: null,
            },
            include: {
                client: {
                    select: {
                        companyName: true,
                        address: true,
                        pointOfContact: true,
                        pointOfContactEmail: true,
                        pointOfContactPhone: true,
                        user: {
                            select: {
                                email: true,
                                phone: true,
                            },
                        },
                    },
                },
                radmin: {
                    select: {
                        firstName: true,
                        lastName: true,
                    },
                },
                serviceCategory: {
                    select: { name: true },
                },
            },
        });
    }

    async getProjectsStats(pentesterId: string) {
        const [total, active, completed, notStarted, inProgress, testingComplete] = await Promise.all([
            this.prisma.project.count({
                where: { pentesterId, deletedAt: null },
            }),
            this.prisma.project.count({
                where: {
                    pentesterId,
                    status: { in: ['NOT_STARTED', 'IN_PROGRESS', 'TESTING_COMPLETE'] },
                    deletedAt: null,
                },
            }),
            this.prisma.project.count({
                where: { pentesterId, status: 'COMPLETED', deletedAt: null },
            }),
            this.prisma.project.count({
                where: { pentesterId, status: 'NOT_STARTED', deletedAt: null },
            }),
            this.prisma.project.count({
                where: { pentesterId, status: 'IN_PROGRESS', deletedAt: null },
            }),
            this.prisma.project.count({
                where: { pentesterId, status: 'TESTING_COMPLETE', deletedAt: null },
            }),
        ]);

        return {
            totalProjects: total,
            activeProjects: active,
            completedProjects: completed,
            notStarted,
            inProgress,
            testingComplete,
        };
    }

    async updateProjectStatus(projectId: string, pentesterId: string, status: ProjectStatus) {
        return this.prisma.project.update({
            where: { id: projectId },
            data: { status },
        });
    }

    async getAvailableProjectsForUpload(pentesterId: string) {
        return this.prisma.project.findMany({
            where: {
                pentesterId,
                status: { in: ['IN_PROGRESS', 'TESTING_COMPLETE'] },
                deletedAt: null,
            },
            select: {
                id: true,
                name: true,
                status: true,
                client: {
                    select: { companyName: true },
                },
                serviceCategory: {
                    select: { name: true },
                },
            },
        });
    }
}


===== src\pentester\repositories\pentester-reports.repository.ts =====
// src/pentester/repositories/pentester-reports.repository.ts

import { Injectable } from '@nestjs/common';
import { PrismaService } from '@core/database/prisma.service';
import { ReportStatus } from '@prisma/client';

@Injectable()
export class PentesterReportsRepository {
    constructor(private readonly prisma: PrismaService) { }

    async findAllReports(params: {
        pentesterId: string;
        page: number;
        limit: number;
        search?: string;
        status?: string;
    }) {
        const { pentesterId, page, limit, search, status } = params;
        const skip = (page - 1) * limit;

        const where: any = {
            pentesterId,
        };

        if (search) {
            where.OR = [
                { project: { name: { contains: search, mode: 'insensitive' } } },
                { fileName: { contains: search, mode: 'insensitive' } },
            ];
        }

        if (status && status !== 'all') {
            where.status = status as ReportStatus;
        }

        const [reports, total] = await Promise.all([
            this.prisma.report.findMany({
                where,
                skip,
                take: limit,
                orderBy: { submittedAt: 'desc' },
                include: {
                    project: {
                        select: {
                            id: true,
                            name: true,
                            client: {
                                select: {
                                    companyName: true,
                                    user: { select: { email: true } },
                                },
                            },
                            serviceCategory: {
                                select: { name: true },
                            },
                        },
                    },
                    reviewer: {
                        select: {
                            firstName: true,
                            lastName: true,
                            email: true,
                        },
                    },
                },
            }),
            this.prisma.report.count({ where }),
        ]);

        return { reports, total };
    }

    async findReportById(reportId: string, pentesterId: string) {
        return this.prisma.report.findFirst({
            where: {
                id: reportId,
                pentesterId,
            },
            include: {
                project: {
                    select: {
                        id: true,
                        name: true,
                        client: {
                            select: {
                                companyName: true,
                                user: { select: { email: true } },
                            },
                        },
                        serviceCategory: {
                            select: { name: true },
                        },
                    },
                },
                reviewer: {
                    select: {
                        firstName: true,
                        lastName: true,
                        email: true,
                    },
                },
            },
        });
    }

    async findReportDetails(reportId: string, pentesterId: string) {
        return this.prisma.report.findFirst({
            where: {
                id: reportId,
                pentesterId,
            },
            include: {
                project: {
                    select: {
                        id: true,
                        name: true,
                        client: {
                            select: {
                                companyName: true,
                                user: { select: { email: true } },
                            },
                        },
                        serviceCategory: {
                            select: { name: true },
                        },
                    },
                },
                reviewer: {
                    select: {
                        firstName: true,
                        lastName: true,
                        email: true,
                    },
                },
                checks: {
                    include: {
                        securityCheck: true,
                    },
                },
                history: {
                    orderBy: { createdAt: 'desc' },
                },
            },
        });
    }

    async getReportsStats(pentesterId: string) {
        const [total, underReview, approved, rejected] = await Promise.all([
            this.prisma.report.count({
                where: { pentesterId },
            }),
            this.prisma.report.count({
                where: { pentesterId, status: 'UNDER_REVIEW' },
            }),
            this.prisma.report.count({
                where: { pentesterId, status: 'APPROVED' },
            }),
            this.prisma.report.count({
                where: { pentesterId, status: 'REJECTED' },
            }),
        ]);

        return { total, underReview, approved, rejected };
    }

    async createReport(data: {
        projectId: string;
        pentesterId: string;
        fileName: string;
        fileUrl: string;
        fileSize: number;
        fileType: string;
        submissionNotes?: string;
        version: number;
    }) {
        return this.prisma.report.create({
            data: {
                projectId: data.projectId,
                pentesterId: data.pentesterId,
                fileName: data.fileName,
                fileUrl: data.fileUrl,
                fileSize: data.fileSize,
                fileType: data.fileType,
                submissionNotes: data.submissionNotes,
                version: data.version,
                status: 'PENDING',
            },
        });
    }

    async createReportChecks(reportId: string, checks: Record<string, boolean>) {
        const checkEntries = Object.entries(checks).map(([name, completed]) => ({
            reportId,
            securityCheckId: name,
            completed,
        }));

        return this.prisma.reportCheck.createMany({
            data: checkEntries as any,
        });
    }

    async getLatestReportVersion(projectId: string) {
        const latestReport = await this.prisma.report.findFirst({
            where: { projectId },
            orderBy: { version: 'desc' },
            select: { version: true },
        });

        return latestReport?.version || 0;
    }
}


===== src\pentester\dto\pentester-query.dto.ts =====
// src/pentester/dto/pentester-query.dto.ts

import { IsOptional, IsString, IsInt, Min, IsIn } from 'class-validator';
import { Type } from 'class-transformer';

export class PentesterProjectQueryDto {
    @IsOptional()
    @Type(() => Number)
    @IsInt()
    @Min(1)
    page?: number = 1;

    @IsOptional()
    @Type(() => Number)
    @IsInt()
    @Min(1)
    limit?: number = 10;

    @IsOptional()
    @IsString()
    search?: string;

    @IsOptional()
    @IsString()
    @IsIn(['all', 'NOT_STARTED', 'IN_PROGRESS', 'TESTING_COMPLETE', 'REPORT_SUBMITTED', 'UNDER_REVIEW', 'COMPLETED', 'REJECTED'])
    status?: string;

    @IsOptional()
    @IsString()
    service?: string;
}

export class PentesterReportQueryDto {
    @IsOptional()
    @Type(() => Number)
    @IsInt()
    @Min(1)
    page?: number = 1;

    @IsOptional()
    @Type(() => Number)
    @IsInt()
    @Min(1)
    limit?: number = 10;

    @IsOptional()
    @IsString()
    search?: string;

    @IsOptional()
    @IsString()
    @IsIn(['all', 'PENDING', 'UNDER_REVIEW', 'APPROVED', 'REJECTED', 'RESUBMITTED'])
    status?: string;
}


===== src\pentester\dto\submit-report.dto.ts =====
// src/pentester/dto/submit-report.dto.ts

import { IsString, IsNotEmpty, IsBoolean, IsOptional, IsUUID } from 'class-validator';

export class SubmitReportDto {
    @IsUUID()
    @IsNotEmpty()
    projectId: string;

    @IsString()
    @IsOptional()
    submissionNotes?: string;

    @IsBoolean()
    @IsNotEmpty()
    executiveSummary: boolean;

    @IsBoolean()
    @IsNotEmpty()
    vulnerabilityDetails: boolean;

    @IsBoolean()
    @IsNotEmpty()
    riskRatings: boolean;

    @IsBoolean()
    @IsNotEmpty()
    remediationSteps: boolean;

    @IsBoolean()
    @IsNotEmpty()
    evidenceAttached: boolean;
}

export class ResubmitReportDto extends SubmitReportDto {
    @IsUUID()
    @IsNotEmpty()
    previousReportId: string;
}

export class UpdateProjectStatusDto {
    @IsString()
    @IsNotEmpty()
    status: string;

    @IsString()
    @IsOptional()
    notes?: string;
}


===== src\pentester\dto\update-profile.dto.ts =====
// src/pentester/dto/update-profile.dto.ts

import { IsString, IsNotEmpty, MinLength, MaxLength, Matches, IsOptional } from 'class-validator';
import { PHONE_REGEX } from '@admin/constants/admin.constants';

export class UpdatePentesterProfileDto {
    @IsString()
    @IsNotEmpty()
    @MinLength(2)
    @MaxLength(50)
    firstName: string;

    @IsString()
    @IsNotEmpty()
    @MinLength(2)
    @MaxLength(50)
    lastName: string;

    @IsString()
    @IsNotEmpty()
    @Matches(PHONE_REGEX)
    phone: string;

    @IsString()
    @IsNotEmpty()
    specialization: string;

    @IsString()
    @IsNotEmpty()
    location: string;

    @IsString()
    @IsOptional()
    bio?: string;
}


===== src\pentester\types\pentester-response.types.ts =====
// src/pentester/types/pentester-response.types.ts

export interface PentesterProfileResponse {
    id: string;
    firstName: string;
    lastName: string;
    email: string;
    phone: string;
    specialization: string;
    location: string;
    bio: string;
    memberSince: string;
    status: string;
}

export interface PentesterProfileStats {
    totalProjects: number;
    completedProjects: number;
    inProgressProjects: number;
    successRate: string;
}

export interface PentesterDashboardStats {
    activeProjects: number;
    upcomingDeadlines: number;
    underReview: number;
    rejected: number;
}

export interface UpcomingDeadline {
    id: string;
    projectName: string;
    client: string;
    daysLeft: number;
    status: string;
}

export interface DashboardProject {
    id: string;
    name: string;
    client: string;
    service: string;
    status: string;
    deadline: string;
    daysLeft: number;
}

export interface RecentActivity {
    id: string;
    type: string;
    message: string;
    time: string;
    status: string;
}

export interface PentesterDashboardResponse {
    stats: PentesterDashboardStats;
    upcomingDeadlines: UpcomingDeadline[];
    myProjects: DashboardProject[];
    recentActivities: RecentActivity[];
}

export interface ProjectListItem {
    id: string;
    name: string;
    client: string;
    company: string;
    service: string;
    status: string;
    priority: string;
    startDate: string;
    endDate: string;
    daysLeft: number;
    scope: string;
    objectives: string;
}

export interface ProjectDetails extends ProjectListItem {
    email: string;
    phone: string;
    address: string;
    targetUrls: string;
    createdBy: string;
    createdAt: string;
}

export interface ProjectsStatsResponse {
    totalProjects: number;
    activeProjects: number;
    completedProjects: number;
    notStarted: number;
    inProgress: number;
    testingComplete: number;
}

export interface ReportCheck {
    id: string;
    name: string;
    completed: boolean;
}

export interface ReportHistoryItem {
    id: string;
    version: number;
    status: string;
    submittedDate: string;
    reviewedDate: string;
    fileName: string;
    fileUrl: string;
    rejectionReason: string | null;
}

export interface ReportListItem {
    id: string;
    projectName: string;
    projectId: string;
    client: string;
    service: string;
    version: number;
    status: string;
    submittedDate: string;
    reviewedDate: string | null;
    reviewedBy: string | null;
    reviewerEmail: string | null;
    rejectionReason: string | null;
    fileName: string;
    fileSize: string;
    fileUrl: string;
    submissionNotes: string | null;
}

export interface ReportDetails extends ReportListItem {
    checksCompleted: ReportCheck[];
    history: ReportHistoryItem[];
}

export interface ReportsStatsResponse {
    total: number;
    underReview: number;
    approved: number;
    rejected: number;
}

export interface UploadProject {
    id: string;
    name: string;
    status: string;
    clientName: string;
    serviceName: string;
    projectName: string;
}


===== src\pentester\pentester.module.ts =====
// src/pentester/pentester.module.ts

import { Module } from '@nestjs/common';
import { PrismaModule } from '@core/database/prisma.module';
import { LoggerModule } from '@core/logger/logger.module';
import { AuthModule } from '@auth/auth.module';

import { PentesterController } from './controllers/pentester.controller';
import { PentesterProjectsController } from './controllers/pentester-projects.controller';
import { PentesterReportsController } from './controllers/pentester-reports.controller';

import { PentesterService } from './services/pentester.service';
import { PentesterProjectsService } from './services/pentester-projects.service';
import { PentesterReportsService } from './services/pentester-reports.service';

import { PentesterRepository } from './repositories/pentester.repository';
import { PentesterProjectsRepository } from './repositories/pentester-projects.repository';
import { PentesterReportsRepository } from './repositories/pentester-reports.repository';

@Module({
    imports: [PrismaModule, LoggerModule, AuthModule],
    controllers: [
        PentesterController,
        PentesterProjectsController,
        PentesterReportsController,
    ],
    providers: [
        PentesterService,
        PentesterProjectsService,
        PentesterReportsService,
        PentesterRepository,
        PentesterProjectsRepository,
        PentesterReportsRepository,
    ],
    exports: [
        PentesterService,
        PentesterProjectsService,
        PentesterReportsService,
    ],
})
export class PentesterModule { }


