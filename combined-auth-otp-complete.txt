===== src/auth/auth.module.ts =====
// src/auth/auth.module.ts

import { Module } from '@nestjs/common';
import { JwtModule } from '@nestjs/jwt';
import { ConfigModule, ConfigService } from '@nestjs/config';

// Controllers
import { AuthController } from './controllers/auth.controller';
import { OTPController } from './controllers/otp.controller';
import { OAuthController } from './controllers/oauth.controller';

// Services
import { AuthService } from './services/auth.service';
import { SessionService } from './services/session.service';
import { OTPService } from './services/otp.service';

// OAuth Services
// import { OAuthBaseService } from './services/oauth/oauth-base.service'; // REMOVE THIS IMPORT
import { GoogleOAuthService } from './services/oauth/google-oauth.service';

// Repositories
import { AuthRepository } from './repositories/auth.repository';

// Guards
import { AuthGuard } from './guards/auth.guard';
import { RolesGuard } from './guards/roles.guard';

// Modules
import { CommonModule } from '@common/common.module';
import { MailModule } from '@core/mail/mail.module';
import { LoggerModule } from '@core/logger/logger.module';

@Module({
    imports: [
        CommonModule,
        ConfigModule,
        MailModule,
        LoggerModule,
        JwtModule.registerAsync({
            imports: [ConfigModule],
            inject: [ConfigService],
            useFactory: async (configService: ConfigService) => ({
                secret: configService.get<string>('JWT_SECRET') || 'your-secret-key',
                signOptions: {
                    expiresIn: '7d',
                },
            }),
        }),
    ],
    controllers: [
        AuthController,
        OTPController,
        OAuthController,
    ],
    providers: [
        // Core Services
        AuthService,
        SessionService,
        OTPService,

        // OAuth Services - ONLY concrete implementations
        GoogleOAuthService, // KEEP THIS

        // Repositories
        AuthRepository,

        // Guards
        AuthGuard,
        RolesGuard,
    ],
    exports: [
        AuthService,
        SessionService,
        OTPService,
        AuthGuard,
        RolesGuard,
    ],
})
export class AuthModule { }


===== src/auth/controllers/auth.controller.ts =====
// src/auth/controllers/auth.controller.ts

import {
    Controller,
    Post,
    Get,
    Body,
    Res,
    Req,
    UseGuards,
    HttpCode,
    HttpStatus,
} from '@nestjs/common';
import type { Request, Response } from 'express';
import { AuthService } from '../services/auth.service';
import { TokenService } from '@common/services/token.service';
import { AuthGuard } from '../guards/auth.guard';
import { CurrentUser } from '../decorators/current-user.decorator';
import { Public } from '../decorators/public.decorator';
import type { User } from '@prisma/client';
import { CookieConfig } from '@config/cookie.config';
import { sanitizeIpAddress, sanitizeUserAgent } from '../utils/auth.utils';

/**
 * Auth Controller
 * Handles common auth endpoints (logout, get current user, etc.)
 */
@Controller('auth')
export class AuthController {
    constructor(
        private readonly authService: AuthService,
        private readonly tokenService: TokenService,
    ) { }

    // ============================================
    // GET CURRENT USER
    // ============================================

    /**
     * Get current authenticated user
     * GET /auth/me
     */
    @Get('me')
    @UseGuards(AuthGuard)
    @HttpCode(HttpStatus.OK)
    async getCurrentUser(@CurrentUser() user: User) {
        return await this.authService.getCurrentUser(user.id);
    }

    // ============================================
    // GET WEBSOCKET TOKEN
    // ============================================

    /**
     * Get JWT token for WebSocket authentication
     * GET /auth/ws-token
     */
    @Get('ws-token')
    @UseGuards(AuthGuard)
    @HttpCode(HttpStatus.OK)
    async getWebSocketToken(@CurrentUser() user: User) {
        // Generate JWT token for WebSocket authentication
        const wsToken = this.tokenService.createJwtToken(
            user.id,
            user.email,
            user.role,
        );

        return {
            token: wsToken,
            expiresIn: '7d',
            id: user.id,
            email: user.email,
            firstName: user.firstName,
            lastName: user.lastName,
            role: user.role,
        };
    }

    // ============================================
    // LOGOUT
    // ============================================

    /**
     * Logout user from current device
     * POST /auth/logout
     */
    @Post('logout')
    @UseGuards(AuthGuard)
    @HttpCode(HttpStatus.OK)
    async logout(
        @Req() req: Request,
        @Res({ passthrough: true }) res: Response,
    ) {
        // Get session token from cookie
        const sessionToken = req.cookies[CookieConfig.COOKIE_NAMES.SESSION];

        if (sessionToken) {
            // Delete session from database
            await this.authService.logout(sessionToken);
        }

        // Clear cookie
        res.clearCookie(
            CookieConfig.COOKIE_NAMES.SESSION,
            CookieConfig.getClearCookieOptions(),
        );

        return {
            message: 'Logout successful',
        };
    }

    // ============================================
    // LOGOUT FROM ALL DEVICES
    // ============================================

    /**
     * Logout user from all devices
     * POST /auth/logout-all
     */
    @Post('logout-all')
    @UseGuards(AuthGuard)
    @HttpCode(HttpStatus.OK)
    async logoutFromAllDevices(
        @CurrentUser() user: User,
        @Res({ passthrough: true }) res: Response,
    ) {
        // Delete all sessions for this user
        await this.authService.logoutFromAllDevices(user.id);

        // Clear cookie
        res.clearCookie(
            CookieConfig.COOKIE_NAMES.SESSION,
            CookieConfig.getClearCookieOptions(),
        );

        return {
            message: 'Logged out from all devices successfully',
        };
    }
}


===== src/auth/controllers/oauth.controller.ts =====
// src/auth/controllers/oauth.controller.ts

import {
    Controller,
    Get,
    Query,
    Res,
    Req,
    HttpCode,
    HttpStatus,
    BadRequestException,
    InternalServerErrorException,
} from '@nestjs/common';
import type { Request, Response } from 'express';
import { GoogleOAuthService } from '../services/oauth/google-oauth.service';
import { Public } from '../decorators/public.decorator';
import { CookieConfig } from '@config/cookie.config';
import { UserRole } from '@prisma/client';
import { sanitizeIpAddress } from '../utils/auth.utils';
import { ErrorCodes } from '@common/enums/error-codes.enum';
import { AppLogger } from '@core/logger/logger.service';

/**
 * OAuth Controller
 * Handles OAuth authentication flows (Google) for R-Admin and Pentester
 */
@Controller('auth')
export class OAuthController {
    constructor(
        private readonly googleOAuthService: GoogleOAuthService,
        private readonly logger: AppLogger,
    ) { }

    // ============================================
    // GOOGLE OAUTH
    // ============================================

    /**
     * Initiate Google OAuth flow
     * GET /auth/google?role=R_ADMIN
     * 
     * Response: { data: { url: "https://accounts.google.com/...", provider: "GOOGLE" } }
     */
    @Public()
    @Get('google')
    @HttpCode(HttpStatus.OK)
    async googleAuth(@Query('role') roleParam?: string) {
        try {
            // Parse role (must be R_ADMIN or PENTESTER)
            const role = this.parseRole(roleParam);

            // Generate authorization URL
            const { url } = await this.googleOAuthService.getAuthorizationUrl(role);

            this.logger.log(`Google OAuth URL generated for role: ${role}`, 'OAuthController');

            // Return JSON - frontend will open this URL in popup
            return {
                data: {
                    url,
                    provider: 'GOOGLE',
                },
                message: 'Google OAuth URL generated successfully',
            };
        } catch (error) {
            this.logger.error('Failed to generate Google OAuth URL', error.stack, 'OAuthController');

            if (error instanceof BadRequestException) {
                throw error;
            }

            throw new InternalServerErrorException({
                code: ErrorCodes.OAUTH_INIT_FAILED,
                message: 'Failed to initialize Google OAuth. Please try again.',
            });
        }
    }

    /**
     * Google OAuth callback
     * GET /auth/google/callback?code=xxx&state=xxx
     */
    @Public()
    @Get('google/callback')
    async googleCallback(
        @Query('code') code: string,
        @Query('state') state: string,
        @Req() req: Request,
        @Res() res: Response,
    ) {
        // Validate parameters
        if (!code || !state) {
            this.logger.warn('Google OAuth callback: Missing code or state', 'OAuthController');
            const appUrl = process.env.APP_URL || 'http://localhost:3000';
            return res.redirect(`${appUrl}/login?error=oauth_params_missing`);
        }

        try {
            const ipAddress = sanitizeIpAddress(req.ip || req.socket.remoteAddress);

            // Handle OAuth callback
            const result = await this.googleOAuthService.handleCallback(
                code,
                state,
                ipAddress,
            );

            // Set session cookie
            res.cookie(
                CookieConfig.COOKIE_NAMES.SESSION,
                result.sessionToken,
                CookieConfig.getSessionCookieOptions(false),
            );

            this.logger.log(
                `Google OAuth successful for user: ${result.user.email}`,
                'OAuthController'
            );

            // Redirect to frontend callback page
            const appUrl = process.env.APP_URL || 'http://localhost:3000';
            return res.redirect(`${appUrl}/auth/callback`);
        } catch (error) {
            this.logger.error(
                `Google OAuth callback failed: ${error.message}`,
                error.stack,
                'OAuthController'
            );

            const appUrl = process.env.APP_URL || 'http://localhost:3000';
            const errorCode = error.code || ErrorCodes.GOOGLE_AUTH_FAILED;
            return res.redirect(`${appUrl}/login?error=${errorCode}`);
        }
    }

    // ============================================
    // HELPERS
    // ============================================

    /**
     * Parse and validate role parameter
     */
    private parseRole(roleParam?: string): UserRole {
        if (!roleParam) {
            throw new BadRequestException({
                code: 'OAUTH_ROLE_REQUIRED',
                message: 'Role parameter is required (R_ADMIN or PENTESTER)',
            });
        }

        const upperRole = roleParam.toUpperCase();

        // Only R_ADMIN and PENTESTER can use OAuth
        if (upperRole === 'R_ADMIN') {
            return UserRole.R_ADMIN;
        }

        if (upperRole === 'PENTESTER') {
            return UserRole.PENTESTER;
        }

        throw new BadRequestException({
            code: ErrorCodes.OAUTH_INVALID_ROLE,
            message: 'Invalid role. OAuth is only available for R_ADMIN and PENTESTER roles.',
        });
    }
}


===== src/auth/controllers/otp.controller.ts =====
// src/auth/controllers/otp.controller.ts

import {
    Controller,
    Post,
    Body,
    Res,
    Req,
    HttpCode,
    HttpStatus,
} from '@nestjs/common';
import type { Request, Response } from 'express';
import { AuthService } from '../services/auth.service';
import { RequestOTPDto, VerifyOTPDto } from '../dto/login-otp.dto';
import { Public } from '../decorators/public.decorator';
import { CookieConfig } from '@config/cookie.config';
import { sanitizeIpAddress, sanitizeUserAgent } from '../utils/auth.utils';

/**
 * OTP Controller
 * Handles OTP-based authentication for Admin, Client, Partner
 */
@Controller('auth/otp')
export class OTPController {
    constructor(private readonly authService: AuthService) { }

    // ============================================
    // REQUEST OTP (Step 1)
    // ============================================

    /**
     * Request OTP to be sent to email
     * POST /auth/otp/request
     * 
     * Used by: Admin, Client, Partner
     */
    @Public()
    @Post('request')
    @HttpCode(HttpStatus.OK)
    async requestOTP(@Body() dto: RequestOTPDto) {
        return await this.authService.requestOTP(dto.email);
    }

    // ============================================
    // VERIFY OTP (Step 2)
    // ============================================

    /**
     * Verify OTP and login user
     * POST /auth/otp/verify
     * 
     * Used by: Admin, Client, Partner
     */
    @Public()
    @Post('verify')
    @HttpCode(HttpStatus.OK)
    async verifyOTP(
        @Body() dto: VerifyOTPDto,
        @Req() req: Request,
        @Res({ passthrough: true }) res: Response,
    ) {
        // Sanitize IP address and user agent
        const ipAddress = sanitizeIpAddress(req.ip || req.socket.remoteAddress);
        const userAgent = sanitizeUserAgent(req.headers['user-agent']);

        // Verify OTP and login
        const result = await this.authService.verifyOTPAndLogin(
            dto.email,
            dto.code,
            ipAddress,
            userAgent,
        );

        // Set session token in HTTP-only cookie
        const cookieOptions = CookieConfig.getSessionCookieOptions(false);
        res.cookie(
            CookieConfig.COOKIE_NAMES.SESSION,
            result.sessionToken,
            cookieOptions,
        );

        // Return user data (no sessionToken in response body)
        return {
            data: result.user,
            message: 'Login successful',
        };
    }
}


===== src/auth/decorators/current-user.decorator.ts =====
// src/auth/decorators/current-user.decorator.ts

import { createParamDecorator, ExecutionContext } from '@nestjs/common';
import { User } from '@prisma/client';

/**
 * Current User Decorator
 * Extracts user from request object (attached by AuthGuard)
 * 
 * Usage:
 * @Get('me')
 * @UseGuards(AuthGuard)
 * async getProfile(@CurrentUser() user: User) {
 *   return user;
 * }
 * 
 * @Get('email')
 * @UseGuards(AuthGuard)
 * async getEmail(@CurrentUser('email') email: string) {
 *   return { email };
 * }
 */
export const CurrentUser = createParamDecorator(
    (data: keyof User | undefined, ctx: ExecutionContext): User | any => {
        const request = ctx.switchToHttp().getRequest();
        const user = request.user;

        // If no specific field requested, return entire user
        if (!data) {
            return user;
        }

        // If specific field requested (like 'id'), return ONLY that field
        return user?.[data];
    },
);


===== src/auth/decorators/public.decorator.ts =====
// src/auth/decorators/public.decorator.ts

import { SetMetadata } from '@nestjs/common';

/**
 * Public Decorator
 * Marks a route as publicly accessible (no authentication required)
 * 
 * Usage:
 * @Public()
 * @Get('health')
 * async healthCheck() {
 *   return { status: 'ok' };
 * }
 */
export const IS_PUBLIC_KEY = 'isPublic';
export const Public = () => SetMetadata(IS_PUBLIC_KEY, true);


===== src/auth/decorators/roles.decorator.ts =====
// src/auth/decorators/roles.decorator.ts

import { SetMetadata } from '@nestjs/common';
import { UserRole } from '@prisma/client';

/**
 * Roles Decorator
 * Restricts access to specific user roles
 * 
 * Usage:
 * @Roles(UserRole.ADMIN)
 * @Get('admin-only')
 * async adminOnlyEndpoint() {
 *   return { message: 'Admin only' };
 * }
 * 
 * @Roles(UserRole.R_ADMIN, UserRole.PENTESTER)
 * @Get('internal-only')
 * async internalEndpoint() {
 *   return { message: 'R-Admin or Pentester only' };
 * }
 */
export const ROLES_KEY = 'roles';
export const Roles = (...roles: UserRole[]) => SetMetadata(ROLES_KEY, roles);


===== src/auth/dto/login-otp.dto.ts =====
// src/auth/dto/login-otp.dto.ts
import { IsEmail, IsString, MaxLength } from 'class-validator';

/**
 * DTO for requesting OTP (Step 1 of login)
 * Used by: Admin, Client, Partner
 */
export class RequestOTPDto {
    @IsEmail({}, { message: 'Invalid email format' })
    @MaxLength(255, { message: 'Email must not exceed 255 characters' })
    email: string;
}

/**
 * DTO for verifying OTP and logging in (Step 2 of login)
 * Used by: Admin, Client, Partner
 */
export class VerifyOTPDto {
    @IsEmail({}, { message: 'Invalid email format' })
    @MaxLength(255, { message: 'Email must not exceed 255 characters' })
    email: string;

    @IsString({ message: 'OTP code must be a string' })
    @MaxLength(6, { message: 'OTP code must be 6 characters' })
    code: string;
}


===== src/auth/guards/auth.guard.ts =====
// src/auth/guards/auth.guard.ts

import {
    Injectable,
    CanActivate,
    ExecutionContext,
    UnauthorizedException,
} from '@nestjs/common';
import { Reflector } from '@nestjs/core';
import { Request } from 'express';
import { AuthService } from '../services/auth.service';
import { IS_PUBLIC_KEY } from '../decorators/public.decorator';
import { CookieConfig } from '@config/cookie.config';

/**
 * Auth Guard
 * Validates session token from cookie and attaches user to request
 */
@Injectable()
export class AuthGuard implements CanActivate {
    constructor(
        private readonly authService: AuthService,
        private readonly reflector: Reflector,
    ) { }

    async canActivate(context: ExecutionContext): Promise<boolean> {
        // Check if route is marked as public
        const isPublic = this.reflector.getAllAndOverride<boolean>(IS_PUBLIC_KEY, [
            context.getHandler(),
            context.getClass(),
        ]);

        if (isPublic) {
            return true;
        }

        // Get request object
        const request = context.switchToHttp().getRequest<Request>();

        // Extract session token from cookie
        const sessionToken = request.cookies[CookieConfig.COOKIE_NAMES.SESSION];

        if (!sessionToken) {
            throw new UnauthorizedException('No session token found. Please login.');
        }

        try {
            // Validate session and get user
            const user = await this.authService.validateSession(sessionToken);

            // Attach user to request object
            request['user'] = user;

            return true;
        } catch (error) {
            throw new UnauthorizedException(
                error.message || 'Invalid or expired session. Please login again.',
            );
        }
    }
}


===== src/auth/guards/roles.guard.ts =====
// src/auth/guards/roles.guard.ts

import {
    Injectable,
    CanActivate,
    ExecutionContext,
    ForbiddenException,
} from '@nestjs/common';
import { Reflector } from '@nestjs/core';
import { UserRole } from '@prisma/client';
import { ROLES_KEY } from '../decorators/roles.decorator';
import { IS_PUBLIC_KEY } from '../decorators/public.decorator';

/**
 * Roles Guard
 * Enforces role-based access control
 */
@Injectable()
export class RolesGuard implements CanActivate {
    constructor(private readonly reflector: Reflector) { }

    canActivate(context: ExecutionContext): boolean {
        // Check if route is marked as public
        const isPublic = this.reflector.getAllAndOverride<boolean>(IS_PUBLIC_KEY, [
            context.getHandler(),
            context.getClass(),
        ]);

        if (isPublic) {
            return true;
        }

        // Get required roles from decorator
        const requiredRoles = this.reflector.getAllAndOverride<UserRole[]>(
            ROLES_KEY,
            [context.getHandler(), context.getClass()],
        );

        // If no roles are required, allow access
        if (!requiredRoles || requiredRoles.length === 0) {
            return true;
        }

        // Get user from request (attached by AuthGuard)
        const request = context.switchToHttp().getRequest();
        const user = request.user;

        if (!user) {
            throw new ForbiddenException('User not found in request');
        }

        // Check if user has required role
        const hasRole = requiredRoles.includes(user.role);

        if (!hasRole) {
            throw new ForbiddenException(
                `Access denied. Required role(s): ${requiredRoles.join(', ')}`,
            );
        }

        return true;
    }
}


===== src/auth/repositories/auth.repository.ts =====
// src/auth/repositories/auth.repository.ts

import { Injectable } from '@nestjs/common';
import { PrismaService } from '@core/database/prisma.service';
import { User, UserRole, AccountStatus } from '@prisma/client';

/**
 * Auth Repository
 * Handles all database queries related to authentication
 */
@Injectable()
export class AuthRepository {
    constructor(private readonly prisma: PrismaService) { }

    // ============================================
    // USER QUERIES
    // ============================================

    /**
     * Find user by email
     */
    async findUserByEmail(email: string): Promise<User | null> {
        return this.prisma.user.findUnique({
            where: { email },
        });
    }

    /**
     * Find user by ID (with relations based on role)
     */
    async findUserById(userId: string): Promise<User | null> {
        return this.prisma.user.findUnique({
            where: { id: userId },
            include: {
                clientProfile: true,
                partnerProfile: true,
                pentesterProfile: true,
            },
        });
    }

    /**
     * Find user by phone
     */
    async findUserByPhone(phone: string): Promise<User | null> {
        return this.prisma.user.findUnique({
            where: { phone },
        });
    }

    // ============================================
    // USER MUTATIONS
    // ============================================

    /**
     * Create new user
     */
    async createUser(data: {
        email: string;
        password?: string | null;
        firstName: string;
        lastName: string;
        phone: string;
        role: UserRole;
        companyEmail?: string | null;
        companyDomain?: string | null;
    }): Promise<User> {
        return this.prisma.user.create({
            data: {
                email: data.email,
                password: data.password,
                firstName: data.firstName,
                lastName: data.lastName,
                phone: data.phone,
                role: data.role,
                companyEmail: data.companyEmail,
                companyDomain: data.companyDomain,
                status: AccountStatus.PENDING, // Email not verified yet
                isEmailVerified: false,
            },
        });
    }

    /**
     * Update user email verification status
     */
    async markEmailAsVerified(userId: string): Promise<User> {
        return this.prisma.user.update({
            where: { id: userId },
            data: {
                isEmailVerified: true,
                emailVerifiedAt: new Date(),
                status: AccountStatus.ACTIVE, // Account becomes active after verification
            },
        });
    }

    /**
     * Update last login details
     */
    async updateLastLogin(userId: string, ipAddress: string): Promise<User> {
        return this.prisma.user.update({
            where: { id: userId },
            data: {
                lastLogin: new Date(),
                lastLoginIp: ipAddress,
            },
        });
    }

    /**
     * Update account status
     */
    async updateAccountStatus(userId: string, status: AccountStatus): Promise<User> {
        return this.prisma.user.update({
            where: { id: userId },
            data: { status },
        });
    }

    // ============================================
    // SESSION QUERIES
    // ============================================

    /**
     * Find session by token
     */
    async findSessionByToken(token: string) {
        return this.prisma.session.findUnique({
            where: { token },
            include: { user: true },
        });
    }

    /**
     * Find all sessions for a user
     */
    async findUserSessions(userId: string) {
        return this.prisma.session.findMany({
            where: { userId },
            orderBy: { createdAt: 'desc' },
        });
    }

    // ============================================
    // SESSION MUTATIONS
    // ============================================

    /**
     * Create new session
     */
    async createSession(data: {
        userId: string;
        token: string;
        expiresAt: Date;
        rememberMe: boolean;
        userAgent?: string;
        ipAddress?: string;
    }) {
        return this.prisma.session.create({
            data: {
                userId: data.userId,
                token: data.token,
                expiresAt: data.expiresAt,
                rememberMe: data.rememberMe,
                userAgent: data.userAgent,
                ipAddress: data.ipAddress,
            },
        });
    }

    /**
     * Update session last activity
     */
    async updateSessionActivity(sessionId: string) {
        return this.prisma.session.update({
            where: { id: sessionId },
            data: { lastActivity: new Date() },
        });
    }

    /**
     * Delete session by token (logout)
     */
    async deleteSession(token: string): Promise<void> {
        await this.prisma.session.delete({
            where: { token },
        });
    }

    /**
     * Delete all sessions for a user (logout from all devices)
     */
    async deleteAllUserSessions(userId: string): Promise<void> {
        await this.prisma.session.deleteMany({
            where: { userId },
        });
    }

    /**
     * Delete expired sessions (cleanup job)
     */
    async deleteExpiredSessions(): Promise<number> {
        const result = await this.prisma.session.deleteMany({
            where: {
                expiresAt: {
                    lt: new Date(),
                },
            },
        });
        return result.count;
    }
}


===== src/auth/services/auth.service.ts =====
// src/auth/services/auth.service.ts

import {
    Injectable,
    BadRequestException,
    UnauthorizedException,
    NotFoundException,
} from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { AuthRepository } from '../repositories/auth.repository';
import { OTPService } from './otp.service';
import { SessionService } from './session.service';
import { PrismaService } from '@core/database/prisma.service';
import { User, AccountStatus, UserRole, OTPType } from '@prisma/client';
import { AppLogger } from '@core/logger/logger.service';
import { ErrorCodes } from '@common/enums/error-codes.enum';
import { formatUserResponse } from '../utils/auth.utils';

/**
 * Auth Service
 * Main authentication service for PenTrack
 * 
 * Supports:
 * - OTP-based login (Admin, Client, Partner)
 * - OAuth login (R-Admin, Pentester via Google)
 */
@Injectable()
export class AuthService {
    constructor(
        private readonly authRepository: AuthRepository,
        private readonly otpService: OTPService,
        private readonly sessionService: SessionService,
        private readonly prisma: PrismaService,
        private readonly configService: ConfigService,
        private readonly logger: AppLogger,
    ) { }

    // ============================================
    // OTP LOGIN FLOW
    // ============================================

    /**
     * Step 1: Request OTP (send OTP to email)
     * Used by: Admin, Client, Partner
     */
    async requestOTP(email: string): Promise<{ message: string; expiresIn: number }> {
        // Find user by email
        const user = await this.authRepository.findUserByEmail(email);

        if (!user) {
            throw new NotFoundException({
                code: ErrorCodes.USER_NOT_FOUND,
                message: 'No account found with this email address.',
            });
        }

        // Check if user role is allowed to use OTP login
        if (user.role === UserRole.R_ADMIN || user.role === UserRole.PENTESTER) {
            throw new BadRequestException({
                code: 'OTP_NOT_ALLOWED_FOR_ROLE',
                message: 'R-Admin and Pentester must use Google OAuth to login.',
            });
        }

        // Check account status
        if (user.status === AccountStatus.SUSPENDED) {
            throw new UnauthorizedException(ErrorCodes.ACCOUNT_SUSPENDED);
        }

        if (user.status === AccountStatus.DELETED) {
            throw new UnauthorizedException(ErrorCodes.ACCOUNT_DELETED);
        }

        // Send OTP
        await this.otpService.sendOTP(email, OTPType.LOGIN);

        this.logger.log(`OTP requested for ${email}`, 'AuthService');

        return {
            message: 'OTP sent to your email. It will expire in 10 minutes.',
            expiresIn: 600, // 10 minutes in seconds
        };
    }

    /**
     * Step 2: Verify OTP and login
     * Used by: Admin, Client, Partner
     */
    async verifyOTPAndLogin(
        email: string,
        code: string,
        ipAddress: string,
        userAgent: string,
    ): Promise<{
        user: any;
        sessionToken: string;
    }> {
        // Verify OTP
        const userId = await this.otpService.verifyOTP(email, code, OTPType.LOGIN);

        if (!userId) {
            throw new UnauthorizedException({
                code: ErrorCodes.OTP_INVALID,
                message: 'Invalid OTP code.',
            });
        }

        // Get user
        const user = await this.authRepository.findUserById(userId);

        if (!user) {
            throw new NotFoundException(ErrorCodes.USER_NOT_FOUND);
        }

        // Check account status
        if (user.status !== AccountStatus.ACTIVE) {
            throw new UnauthorizedException(ErrorCodes.ACCOUNT_SUSPENDED);
        }

        // Update last login
        await this.authRepository.updateLastLogin(user.id, ipAddress);

        // Create session
        const sessionToken = await this.sessionService.createSession(
            user.id,
            false, // No "remember me" for OTP login
            userAgent,
            ipAddress,
        );

        this.logger.log(`User logged in via OTP: ${user.email}`, 'AuthService');

        return {
            user: formatUserResponse(user),
            sessionToken,
        };
    }

    // ============================================
    // SESSION VALIDATION
    // ============================================

    /**
     * Validate session token and return user
     */
    async validateSession(sessionToken: string): Promise<User> {
        const session = await this.authRepository.findSessionByToken(sessionToken);

        if (!session) {
            throw new UnauthorizedException(ErrorCodes.SESSION_INVALID);
        }

        // Check if session is expired
        if (new Date() > session.expiresAt) {
            await this.authRepository.deleteSession(sessionToken);
            throw new UnauthorizedException(ErrorCodes.SESSION_EXPIRED);
        }

        // Check if user account is active
        if (session.user.status !== AccountStatus.ACTIVE) {
            throw new UnauthorizedException(ErrorCodes.ACCOUNT_SUSPENDED);
        }

        // Update last activity (rolling session)
        await this.authRepository.updateSessionActivity(session.id);

        return session.user;
    }

    // ============================================
    // GET CURRENT USER
    // ============================================

    /**
     * Get current authenticated user with relations
     */
    async getCurrentUser(userId: string) {
        const user = await this.prisma.user.findUnique({
            where: { id: userId },
            include: {
                clientProfile: true,
                partnerProfile: true,
                pentesterProfile: true,
            },
        });

        if (!user) {
            throw new NotFoundException(ErrorCodes.USER_NOT_FOUND);
        }

        return formatUserResponse(user);
    }

    // ============================================
    // LOGOUT
    // ============================================

    /**
     * Logout user and delete session
     */
    async logout(sessionToken: string) {
        await this.authRepository.deleteSession(sessionToken);

        return {
            message: 'Logout successful',
        };
    }

    /**
     * Logout from all devices
     */
    async logoutFromAllDevices(userId: string) {
        await this.authRepository.deleteAllUserSessions(userId);

        return {
            message: 'Logged out from all devices successfully',
        };
    }
}


===== src/auth/services/otp.service.ts =====
// src/auth/services/otp.service.ts

import { Injectable, BadRequestException, UnauthorizedException } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { PrismaService } from '@core/database/prisma.service';
import { MailService } from '@core/mail/mail.service';
import { HashService } from '@common/services/hash.service';
import { AppLogger } from '@core/logger/logger.service';
import { OTPType } from '@prisma/client';
import { ErrorCodes } from '@common/enums/error-codes.enum';

/**
 * OTP Service
 * Handles OTP generation, sending, and verification
 */
@Injectable()
export class OTPService {
    private readonly OTP_LENGTH = 6;
    private readonly OTP_EXPIRY_MINUTES = 10;
    private readonly MAX_ATTEMPTS = 3;
    private readonly RATE_LIMIT_WINDOW_MINUTES = 5;
    private readonly MAX_OTP_REQUESTS = 3;

    constructor(
        private readonly prisma: PrismaService,
        private readonly mailService: MailService,
        private readonly hashService: HashService,
        private readonly configService: ConfigService,
        private readonly logger: AppLogger,
    ) { }

    // ============================================
    // GENERATE OTP
    // ============================================

    /**
     * Generate a random 6-digit OTP code
     */
    private generateOTPCode(): string {
        return Math.floor(100000 + Math.random() * 900000).toString();
    }

    // ============================================
    // SEND OTP
    // ============================================

    /**
     * Send OTP to email
     * Creates OTP record and sends email
     */
    async sendOTP(email: string, type: OTPType): Promise<void> {
        // 1. Check rate limiting
        await this.checkRateLimit(email);

        // 2. Generate OTP code
        const code = this.generateOTPCode();
        const hashedCode = this.hashService.hashToken(code);

        // 3. Calculate expiry
        const expiresAt = new Date();
        expiresAt.setMinutes(expiresAt.getMinutes() + this.OTP_EXPIRY_MINUTES);

        // 4. Get user if exists
        const user = await this.prisma.user.findUnique({
            where: { email },
        });

        // 5. Delete old OTP codes for this email
        await this.prisma.oTPCode.deleteMany({
            where: {
                email,
                type,
            },
        });

        // 6. Create OTP record
        await this.prisma.oTPCode.create({
            data: {
                email,
                code: hashedCode,
                type,
                expiresAt,
                userId: user?.id, // NULL if user doesn't exist yet
            },
        });

        // 7. Send OTP via email
        try {
            await this.mailService.sendOTPEmail(email, code);
            this.logger.log(`OTP sent to ${email}`, 'OTPService');
        } catch (error) {
            this.logger.error(`Failed to send OTP to ${email}`, error.stack, 'OTPService');
            throw new BadRequestException({
                code: ErrorCodes.EMAIL_SEND_FAILED,
                message: 'Failed to send OTP email. Please try again.',
            });
        }
    }

    // ============================================
    // VERIFY OTP
    // ============================================

    /**
     * Verify OTP code
     * Returns user ID if valid
     */
    async verifyOTP(email: string, code: string, type: OTPType): Promise<string | null> {
        // 1. Find OTP record
        const otpRecord = await this.prisma.oTPCode.findFirst({
            where: {
                email,
                type,
                usedAt: null, // Not used yet
            },
            orderBy: {
                createdAt: 'desc', // Get most recent
            },
        });

        if (!otpRecord) {
            throw new UnauthorizedException({
                code: ErrorCodes.OTP_INVALID,
                message: 'Invalid or expired OTP code.',
            });
        }

        // 2. Check if expired
        if (new Date() > otpRecord.expiresAt) {
            // Delete expired OTP
            await this.prisma.oTPCode.delete({
                where: { id: otpRecord.id },
            });

            throw new UnauthorizedException({
                code: ErrorCodes.OTP_EXPIRED,
                message: 'OTP code has expired. Please request a new one.',
            });
        }

        // 3. Check max attempts
        if (otpRecord.attempts >= this.MAX_ATTEMPTS) {
            // Delete OTP after max attempts
            await this.prisma.oTPCode.delete({
                where: { id: otpRecord.id },
            });

            throw new UnauthorizedException({
                code: ErrorCodes.OTP_MAX_ATTEMPTS,
                message: 'Too many failed attempts. Please request a new OTP.',
            });
        }

        // 4. Verify OTP code
        const hashedCode = this.hashService.hashToken(code);
        const isValid = hashedCode === otpRecord.code;

        if (!isValid) {
            // Increment attempt count
            await this.prisma.oTPCode.update({
                where: { id: otpRecord.id },
                data: {
                    attempts: otpRecord.attempts + 1,
                },
            });

            throw new UnauthorizedException({
                code: ErrorCodes.OTP_INVALID,
                message: 'Invalid OTP code.',
            });
        }

        // 5. Mark OTP as used
        await this.prisma.oTPCode.update({
            where: { id: otpRecord.id },
            data: {
                usedAt: new Date(),
            },
        });

        this.logger.log(`OTP verified for ${email}`, 'OTPService');

        return otpRecord.userId;
    }

    // ============================================
    // RATE LIMITING
    // ============================================

    /**
     * Check if user has exceeded OTP request rate limit
     */
    private async checkRateLimit(email: string): Promise<void> {
        const windowStart = new Date();
        windowStart.setMinutes(windowStart.getMinutes() - this.RATE_LIMIT_WINDOW_MINUTES);

        const recentOTPs = await this.prisma.oTPCode.count({
            where: {
                email,
                createdAt: {
                    gte: windowStart,
                },
            },
        });

        if (recentOTPs >= this.MAX_OTP_REQUESTS) {
            throw new BadRequestException({
                code: ErrorCodes.OTP_RATE_LIMIT,
                message: `Too many OTP requests. Please try again in ${this.RATE_LIMIT_WINDOW_MINUTES} minutes.`,
            });
        }
    }

    // ============================================
    // CLEANUP
    // ============================================

    /**
     * Cleanup expired OTP codes (can be run as a cron job)
     */
    async cleanupExpiredOTPs(): Promise<number> {
        const result = await this.prisma.oTPCode.deleteMany({
            where: {
                expiresAt: {
                    lt: new Date(),
                },
            },
        });

        this.logger.log(`Cleaned up ${result.count} expired OTPs`, 'OTPService');
        return result.count;
    }
}


===== src/auth/services/session.service.ts =====
// src/auth/services/session.service.ts

import { Injectable, UnauthorizedException } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { PrismaService } from '@core/database/prisma.service';
import { AppLogger } from '@core/logger/logger.service';
import { randomBytes } from 'crypto';

/**
 * Session Service
 * Handles session creation, validation, and cleanup
 */
@Injectable()
export class SessionService {
    private readonly sessionExpiry: string;
    private readonly sessionRememberMeExpiry: string;

    constructor(
        private readonly prisma: PrismaService,
        private readonly configService: ConfigService,
        private readonly logger: AppLogger,
    ) {
        this.sessionExpiry = this.configService.get<string>('SESSION_EXPIRES_IN', '24h');
        this.sessionRememberMeExpiry = this.configService.get<string>(
            'SESSION_REMEMBER_ME_EXPIRES_IN',
            '30d',
        );
    }

    // ============================================
    // SESSION GENERATION
    // ============================================

    /**
     * Generate a random secure session token
     */
    private generateSessionToken(): string {
        return randomBytes(32).toString('hex'); // 64 character hex string
    }

    /**
     * Calculate session expiry time
     */
    private getExpiryDate(rememberMe: boolean): Date {
        const expiresAt = new Date();

        if (rememberMe) {
            // 30 days for remember me
            const days = parseInt(this.sessionRememberMeExpiry.replace('d', ''));
            expiresAt.setDate(expiresAt.getDate() + days);
        } else {
            // 24 hours for normal session
            const hours = parseInt(this.sessionExpiry.replace('h', ''));
            expiresAt.setHours(expiresAt.getHours() + hours);
        }

        return expiresAt;
    }

    // ============================================
    // CREATE SESSION
    // ============================================

    /**
     * Create a new session for user
     */
    async createSession(
        userId: string,
        rememberMe: boolean = false,
        userAgent?: string,
        ipAddress?: string,
    ): Promise<string> {
        const token = this.generateSessionToken();
        const expiresAt = this.getExpiryDate(rememberMe);

        await this.prisma.session.create({
            data: {
                userId,
                token,
                expiresAt,
                rememberMe,
                userAgent,
                ipAddress,
                lastActivity: new Date(),
            },
        });

        this.logger.log(`Session created for user ${userId}`, 'SessionService');

        return token;
    }

    // ============================================
    // VALIDATE SESSION
    // ============================================

    /**
     * Validate session token and return user
     */
    async validateSession(token: string): Promise<any> {
        const session = await this.prisma.session.findUnique({
            where: { token },
            include: {
                user: {
                    select: {
                        id: true,
                        email: true,
                        firstName: true,
                        lastName: true,
                        phone: true,
                        role: true,
                        status: true,
                        isEmailVerified: true,
                        profileImage: true,
                        companyEmail: true,
                        companyDomain: true,
                        createdAt: true,
                        updatedAt: true,
                    },
                },
            },
        });

        if (!session) {
            throw new UnauthorizedException('Invalid session');
        }

        // Check if session expired
        if (new Date() > session.expiresAt) {
            await this.deleteSession(token);
            throw new UnauthorizedException('Session expired');
        }

        // Check if user account is active
        if (session.user.status !== 'ACTIVE') {
            throw new UnauthorizedException('Account is not active');
        }

        // Update last activity (rolling session)
        await this.prisma.session.update({
            where: { id: session.id },
            data: { lastActivity: new Date() },
        });

        return session.user;
    }

    // ============================================
    // DELETE SESSIONS
    // ============================================

    /**
     * Delete a specific session (logout)
     */
    async deleteSession(token: string): Promise<void> {
        await this.prisma.session.deleteMany({
            where: { token },
        });

        this.logger.log('Session deleted', 'SessionService');
    }

    /**
     * Delete all sessions for a user (logout from all devices)
     */
    async deleteAllUserSessions(userId: string): Promise<void> {
        await this.prisma.session.deleteMany({
            where: { userId },
        });

        this.logger.log(`All sessions deleted for user ${userId}`, 'SessionService');
    }

    // ============================================
    // GET SESSIONS
    // ============================================

    /**
     * Get all active sessions for a user
     */
    async getUserSessions(userId: string): Promise<any[]> {
        return this.prisma.session.findMany({
            where: {
                userId,
                expiresAt: {
                    gt: new Date(), // Not expired
                },
            },
            select: {
                id: true,
                token: true,
                userAgent: true,
                ipAddress: true,
                lastActivity: true,
                createdAt: true,
                expiresAt: true,
                deviceName: true,
                deviceType: true,
            },
            orderBy: {
                lastActivity: 'desc',
            },
        });
    }

    // ============================================
    // SESSION MANAGEMENT
    // ============================================

    /**
     * Refresh session expiry (extend session)
     */
    async refreshSession(token: string): Promise<void> {
        const session = await this.prisma.session.findUnique({
            where: { token },
        });

        if (!session) {
            throw new UnauthorizedException('Invalid session');
        }

        const newExpiresAt = this.getExpiryDate(session.rememberMe);

        await this.prisma.session.update({
            where: { id: session.id },
            data: {
                expiresAt: newExpiresAt,
                lastActivity: new Date(),
            },
        });
    }

    // ============================================
    // CLEANUP
    // ============================================

    /**
     * Cleanup expired sessions (can be run as a cron job)
     */
    async cleanupExpiredSessions(): Promise<number> {
        const result = await this.prisma.session.deleteMany({
            where: {
                expiresAt: {
                    lt: new Date(),
                },
            },
        });

        this.logger.log(`Cleaned up ${result.count} expired sessions`, 'SessionService');

        return result.count;
    }
}


===== src/auth/services/oauth/google-oauth.service.ts =====
// src/auth/services/oauth/google-oauth.service.ts

import { Injectable } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { OAuth2Client, TokenPayload } from 'google-auth-library';
import { UserRole } from '@prisma/client';
import { OAuthBaseService } from './oauth-base.service';
import { PrismaService } from '@core/database/prisma.service';
import { AppLogger } from '@core/logger/logger.service';
import { AuthRepository } from '@auth/repositories/auth.repository';
import { SessionService } from '@auth/services/session.service';
import {
    GoogleOAuthConfig,
    GoogleUserData,
    OAuthTokens,
} from '@auth/types/oauth.types';

/**
 * Google OAuth Service
 * Handles Google OAuth authentication for R-Admin and Pentester roles
 */
@Injectable()
export class GoogleOAuthService extends OAuthBaseService {
    private readonly oauth2Client: OAuth2Client;
    private readonly clientId: string;
    private readonly clientSecret: string;
    private readonly redirectUri: string;

    constructor(
        protected readonly prisma: PrismaService,
        protected readonly logger: AppLogger,
        protected readonly configService: ConfigService,
        protected readonly authRepository: AuthRepository,
        protected readonly sessionService: SessionService,
    ) {
        super(
            prisma,
            logger,
            configService,
            authRepository,
            sessionService,
            'GOOGLE',
        );

        // ✅ FIXED: Proper type handling with defaults
        this.clientId = this.configService.get<string>('GOOGLE_CLIENT_ID') || '';
        this.clientSecret = this.configService.get<string>('GOOGLE_CLIENT_SECRET') || '';
        this.redirectUri = this.configService.get<string>('GOOGLE_REDIRECT_URI') || '';

        // ✅ Validate required config
        if (!this.clientId || !this.clientSecret || !this.redirectUri) {
            this.logger.error(
                'Missing Google OAuth configuration. Please set GOOGLE_CLIENT_ID, GOOGLE_CLIENT_SECRET, and GOOGLE_REDIRECT_URI in .env',
                'GoogleOAuthService',
            );
        }

        this.oauth2Client = new OAuth2Client(
            this.clientId,
            this.clientSecret,
            this.redirectUri,
        );

        this.logger.log('Google OAuth Service initialized', 'GoogleOAuthService');
    }

    /**
     * Generate Google OAuth authorization URL
     * PUBLIC METHOD - Called by OAuthController
     */
    async getAuthorizationUrl(role: UserRole): Promise<{ url: string; state: string }> {
        // Create state for CSRF protection
        const state = await this.createState(role);

        // Generate auth URL
        const url = this.generateAuthUrl(state);

        return { url, state };
    }

    /**
     * Generate Google OAuth authorization URL (internal)
     */
    private generateAuthUrl(state: string): string {
        const config: GoogleOAuthConfig = {
            clientId: this.clientId,
            clientSecret: this.clientSecret,
            redirectUri: this.redirectUri,
            scope: [
                'https://www.googleapis.com/auth/userinfo.email',
                'https://www.googleapis.com/auth/userinfo.profile',
            ],
        };

        const authUrl = this.oauth2Client.generateAuthUrl({
            access_type: 'offline',
            scope: config.scope,
            state: state,
            prompt: 'consent',
        });

        this.logger.log(
            `Generated Google auth URL with state: ${state}`,
            'GoogleOAuthService',
        );

        return authUrl;
    }

    /**
     * Exchange authorization code for tokens
     */
    async exchangeCodeForTokens(code: string): Promise<OAuthTokens> {
        try {
            const { tokens } = await this.oauth2Client.getToken(code);

            this.logger.log('Successfully exchanged code for tokens', 'GoogleOAuthService');

            return {
                access_token: tokens.access_token || '',
                refresh_token: tokens.refresh_token || undefined,
                expires_in: tokens.expiry_date
                    ? Math.floor((tokens.expiry_date - Date.now()) / 1000)
                    : undefined,
                id_token: tokens.id_token || undefined,
            };
        } catch (error) {
            this.logger.error(
                `Failed to exchange code for tokens: ${error.message}`,
                error.stack,
                'GoogleOAuthService',
            );
            throw new Error('Failed to exchange authorization code for tokens');
        }
    }

    /**
     * Verify ID token and extract user data
     * ✅ FIXED: Proper handling of optional id_token
     */
    async verifyIdToken(idToken: string | undefined): Promise<GoogleUserData> {
        if (!idToken) {
            throw new Error('ID token is required');
        }

        try {
            const ticket = await this.oauth2Client.verifyIdToken({
                idToken: idToken,
                audience: this.clientId,
            });

            const payload: TokenPayload | undefined = ticket.getPayload();

            if (!payload) {
                throw new Error('Invalid ID token payload');
            }

            const userData: GoogleUserData = {
                id: payload.sub,
                email: payload.email || '',
                verified_email: payload.email_verified || false,
                name: payload.name || '',
                given_name: payload.given_name || '',
                family_name: payload.family_name || '',
                picture: payload.picture || '',
            };

            this.logger.log(
                `Verified Google user: ${userData.email}`,
                'GoogleOAuthService',
            );

            return userData;
        } catch (error) {
            this.logger.error(
                `Failed to verify ID token: ${error.message}`,
                error.stack,
                'GoogleOAuthService',
            );
            throw new Error('Failed to verify Google ID token');
        }
    }

    /**
     * Complete OAuth flow
     */
    async handleCallback(
        code: string,
        state: string,
        userAgent?: string,
        ipAddress?: string,
    ): Promise<any> {
        // Exchange code for tokens
        const tokens = await this.exchangeCodeForTokens(code);

        // Verify ID token and get user data
        const userData = await this.verifyIdToken(tokens.id_token);

        // Use base service to complete OAuth flow
        return await this.completeOAuthFlow(
            {
                provider: 'GOOGLE',
                providerId: userData.id,
                email: userData.email,
                firstName: userData.given_name,
                lastName: userData.family_name,
                profileImage: userData.picture,
            },
            state,
            userAgent,
            ipAddress,
        );
    }
}


===== src/auth/services/oauth/oauth-base.service.ts =====
// src/auth/services/oauth/oauth-base.service.ts

import { Injectable, UnauthorizedException } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { PrismaService } from '@core/database/prisma.service';
import { SessionService } from '../session.service';
import { AuthRepository } from '@auth/repositories/auth.repository';
import { AppLogger } from '@core/logger/logger.service';
import { randomBytes } from 'crypto';
import type {
    OAuthProvider,
    OAuthUserData,
    OAuthState,
    OAuthLoginResult,
} from '../../types/oauth.types';
import { UserRole, AccountStatus, OAuthProviderType } from '@prisma/client';
import { formatUserResponse } from '../../utils/auth.utils';

/**
 * Base OAuth Service
 * Provides shared logic for all OAuth providers
 * Uses in-memory storage for state management (no Redis dependency)
 */
@Injectable()
export class OAuthBaseService {
    private readonly STATE_EXPIRY = 300000; // 5 minutes in milliseconds
    private readonly ALLOWED_DOMAIN = 'rivedix.com'; // Only @rivedix.com for R-Admin/Pentester

    // In-memory store for OAuth state
    protected inMemoryStore: Map<string, { data: OAuthState; expires: number }> = new Map();

    constructor(
        protected readonly prisma: PrismaService,
        protected readonly logger: AppLogger,
        protected readonly configService: ConfigService,
        protected readonly authRepository: AuthRepository,
        protected readonly sessionService: SessionService,
        protected readonly provider: OAuthProvider,
    ) {
        // Cleanup expired entries every minute
        setInterval(() => this.cleanupExpiredStates(), 60000);
        this.logger.log(`OAuth using in-memory storage for state management (${provider})`, 'OAuthBaseService');
    }

    // ============================================
    // STATE MANAGEMENT (CSRF Protection)
    // ============================================

    /**
     * Cleanup expired in-memory states
     */
    private cleanupExpiredStates() {
        const now = Date.now();
        let cleaned = 0;

        for (const [key, value] of this.inMemoryStore.entries()) {
            if (value.expires < now) {
                this.inMemoryStore.delete(key);
                cleaned++;
            }
        }

        if (cleaned > 0) {
            this.logger.log(`Cleaned ${cleaned} expired OAuth states`, 'OAuthBaseService');
        }
    }

    /**
     * Generate OAuth state token and store in memory
     */
    async createState(
        role: UserRole,
        redirectUrl?: string,
    ): Promise<string> {
        const state = randomBytes(32).toString('hex');
        const nonce = randomBytes(16).toString('hex');

        const stateData: OAuthState = {
            role,
            timestamp: Date.now(),
            nonce,
            redirectUrl,
        };

        const key = `oauth:${this.provider}:state:${state}`;

        // Store in memory
        this.inMemoryStore.set(key, {
            data: stateData,
            expires: Date.now() + this.STATE_EXPIRY,
        });

        this.logger.log(`OAuth state created for ${this.provider}: ${state}`, 'OAuthBaseService');

        return state;
    }

    /**
     * Validate and consume OAuth state
     */
    async validateAndConsumeState(
        state: string,
    ): Promise<OAuthState> {
        const key = `oauth:${this.provider}:state:${state}`;

        // Get from memory
        const stored = this.inMemoryStore.get(key);

        if (!stored) {
            this.logger.warn(`Invalid OAuth state attempted: ${state}`, 'OAuthBaseService');
            throw new UnauthorizedException({
                code: 'OAUTH_STATE_INVALID',
                message: 'Invalid or expired OAuth state. Please try logging in again.',
            });
        }

        if (stored.expires < Date.now()) {
            this.inMemoryStore.delete(key);
            this.logger.warn(`Expired OAuth state attempted: ${state}`, 'OAuthBaseService');
            throw new UnauthorizedException({
                code: 'OAUTH_STATE_EXPIRED',
                message: 'OAuth session expired. Please try logging in again.',
            });
        }

        // Delete state (single use)
        this.inMemoryStore.delete(key);

        const stateData = stored.data;

        // Check if state is not too old (extra security)
        const age = Date.now() - stateData.timestamp;
        if (age > this.STATE_EXPIRY) {
            throw new UnauthorizedException({
                code: 'OAUTH_STATE_EXPIRED',
                message: 'OAuth session expired. Please try logging in again.',
            });
        }

        this.logger.log(`OAuth state validated for ${this.provider}`, 'OAuthBaseService');

        return stateData;
    }

    // ============================================
    // COMPLETE OAUTH FLOW
    // ============================================

    /**
     * Complete OAuth flow after provider callback
     */
    protected async completeOAuthFlow(
        oauthData: OAuthUserData,
        state: string,
        userAgent?: string,
        ipAddress?: string,
    ): Promise<OAuthLoginResult> {
        // Validate state
        const stateData = await this.validateAndConsumeState(state);

        // Find or create user
        return await this.findOrCreateUser(oauthData, stateData.role, ipAddress);
    }

    // ============================================
    // FIND OR CREATE USER
    // ============================================

    /**
     * Find existing user or create new one from OAuth data
     * Handles account linking if email already exists
     * 
     * PenTrack Rules:
     * - R-Admin and Pentester MUST have @rivedix.com email
     * - Other roles are not allowed via OAuth
     */
    async findOrCreateUser(
        oauthData: OAuthUserData,
        role: UserRole,
        ipAddress?: string,
    ): Promise<OAuthLoginResult> {
        let isNewUser = false;
        let linkedAccount = false;

        // ✅ Validate email domain for R-Admin/Pentester
        if (role === UserRole.R_ADMIN || role === UserRole.PENTESTER) {
            const emailDomain = oauthData.email.split('@')[1];
            if (emailDomain !== this.ALLOWED_DOMAIN) {
                throw new UnauthorizedException({
                    code: 'OAUTH_DOMAIN_NOT_ALLOWED',
                    message: `Only @${this.ALLOWED_DOMAIN} email addresses are allowed for ${role} role.`,
                });
            }
        } else {
            // OAuth is only for R-Admin and Pentester
            throw new UnauthorizedException({
                code: 'OAUTH_ROLE_NOT_ALLOWED',
                message: `OAuth login is only available for R-Admin and Pentester roles.`,
            });
        }

        // 1. Try to find user by email
        let user = await this.prisma.user.findUnique({
            where: { email: oauthData.email },
            include: {
                clientProfile: true,
                partnerProfile: true,
                pentesterProfile: true,
            },
        });

        if (user) {
            // 2. Check if email account already has this provider linked
            const hasProvider = await this.hasOAuthProvider(user.id, oauthData.provider);

            if (!hasProvider) {
                // 3. Link OAuth provider to existing account
                await this.linkOAuthProvider(
                    user.id,
                    oauthData.provider,
                    oauthData.providerId,
                    oauthData.email,
                    `${oauthData.firstName} ${oauthData.lastName}`,
                    oauthData.profileImage,
                );

                linkedAccount = true;

                this.logger.log(
                    `Linked ${oauthData.provider} to existing user: ${user.email}`,
                    'OAuthBaseService',
                );
            }

            // 4. Check role mismatch
            if (user.role !== role) {
                this.logger.warn(
                    `OAuth role mismatch for ${user.email}: expected ${role}, got ${user.role}`,
                    'OAuthBaseService',
                );
                throw new UnauthorizedException({
                    code: 'OAUTH_ROLE_MISMATCH',
                    message: `This account is registered as ${user.role}. Please use the correct role to login.`,
                });
            }

            // 5. Update last login
            await this.prisma.user.update({
                where: { id: user.id },
                data: {
                    lastLogin: new Date(),
                    lastLoginIp: ipAddress,
                },
            });
        } else {
            // 6. Create new user with OAuth provider
            user = await this.createOAuthUser(oauthData, role, ipAddress);

            if (!user) {
                throw new Error('Failed to create OAuth user');
            }

            isNewUser = true;

            this.logger.log(
                `Created new user via ${oauthData.provider}: ${user.email}`,
                'OAuthBaseService',
            );
        }

        if (!user) {
            throw new Error('User not found or created');
        }

        // 7. Create session
        const sessionToken = await this.sessionService.createSession(
            user.id,
            false, // OAuth doesn't use "remember me"
            undefined,
            ipAddress,
        );

        return {
            user: formatUserResponse(user),
            sessionToken,
            isNewUser,
            linkedAccount,
        };
    }

    // ============================================
    // OAUTH PROVIDER MANAGEMENT
    // ============================================

    /**
     * Check if user has specific OAuth provider linked
     */
    private async hasOAuthProvider(
        userId: string,
        provider: OAuthProvider,
    ): Promise<boolean> {
        const existingProvider = await this.prisma.oAuthProvider.findUnique({
            where: {
                userId_provider: {
                    userId,
                    provider: provider as unknown as OAuthProviderType,
                },
            },
        });

        return !!existingProvider;
    }

    /**
     * Link OAuth provider to existing user
     */
    private async linkOAuthProvider(
        userId: string,
        provider: OAuthProvider,
        providerId: string,
        email: string,
        name: string,
        picture?: string,
    ): Promise<void> {
        await this.prisma.oAuthProvider.create({
            data: {
                userId,
                provider: provider as unknown as OAuthProviderType,
                providerId,
                email,
                name,
                picture,
            },
        });

        this.logger.log(
            `Linking ${provider} (${providerId}) to user ${userId}`,
            'OAuthBaseService',
        );
    }

    // ============================================
    // CREATE OAUTH USER
    // ============================================

    /**
     * Create new user from OAuth data
     */
    private async createOAuthUser(
        oauthData: OAuthUserData,
        role: UserRole,
        ipAddress?: string,
    ): Promise<any> {
        return this.prisma.$transaction(async (tx) => {
            // Extract company email and domain from @rivedix.com email
            const companyEmail = oauthData.email;
            const companyDomain = oauthData.email.split('@')[1];

            // 1. Create user (no password for OAuth)
            const user = await tx.user.create({
                data: {
                    email: oauthData.email,
                    password: null, // No password for OAuth users
                    firstName: oauthData.firstName,
                    lastName: oauthData.lastName,
                    phone: '', // Will be filled later if needed
                    profileImage: oauthData.profileImage,
                    role,
                    companyEmail,
                    companyDomain,
                    isEmailVerified: true, // OAuth emails are pre-verified
                    emailVerifiedAt: new Date(),
                    status: AccountStatus.ACTIVE,
                    lastLoginIp: ipAddress,
                },
            });

            // 2. Link OAuth provider
            await tx.oAuthProvider.create({
                data: {
                    userId: user.id,
                    provider: oauthData.provider as unknown as OAuthProviderType,
                    providerId: oauthData.providerId,
                    email: oauthData.email,
                    name: `${oauthData.firstName} ${oauthData.lastName}`,
                    picture: oauthData.profileImage,
                },
            });

            // 3. Create role-specific profile
            if (role === UserRole.PENTESTER) {
                await tx.pentester.create({
                    data: {
                        userId: user.id,
                        specialization: '', // To be filled later
                        location: '',
                        bio: null,
                    },
                });
            }

            return user;
        });
    }
}


===== src/auth/types/auth-response.types.ts =====
// src/auth/types/auth-response.types.ts

/**
 * User response structure (matches frontend UserProfile types)
 */
export interface UserResponse {
    id: string;
    email: string;
    firstName: string;
    lastName: string;
    phone: string;
    role: 'ADMIN' | 'R_ADMIN' | 'PENTESTER' | 'CLIENT' | 'PARTNER';
    status: 'ACTIVE' | 'INACTIVE' | 'PENDING' | 'SUSPENDED' | 'DELETED';
    isEmailVerified: boolean;
    profileImage?: string | null;
    companyEmail?: string | null;
    companyDomain?: string | null;

    // Extended profile data based on role
    clientProfile?: any;
    partnerProfile?: any;
    pentesterProfile?: any;
}

/**
 * Base response structure
 */
export interface BaseResponse {
    success: boolean;
    message: string;
}

/**
 * OTP request response
 */
export interface RequestOTPResponse extends BaseResponse {
    expiresIn: number; // Seconds until OTP expires
}

/**
 * Login response (after OTP verification or OAuth)
 */
export interface LoginResponse extends BaseResponse {
    user: UserResponse;
}

/**
 * Get current user response
 */
export interface GetMeResponse {
    success: boolean;
    user: UserResponse;
}


===== src/auth/types/oauth.types.ts =====
// src/auth/types/oauth.types.ts

import { UserRole } from '@prisma/client';

/**
 * OAuth provider names
 */
export type OAuthProvider = 'GOOGLE' | 'MICROSOFT'; // Simple string type

/**
 * OAuth user data from provider
 */
export interface OAuthUserData {
    providerId: string; // Unique ID from provider (Google's "sub")
    email: string;
    firstName: string;
    lastName: string;
    profileImage?: string;
    provider: OAuthProvider;
}

/**
 * OAuth state data (stored in memory/Redis for CSRF protection)
 */
export interface OAuthState {
    role: UserRole;
    timestamp: number;
    nonce: string; // Additional security
    redirectUrl?: string; // Where to redirect after auth
}

/**
 * OAuth login result
 */
export interface OAuthLoginResult {
    user: any;
    sessionToken: string;
    isNewUser: boolean;
    linkedAccount: boolean; // True if linked to existing account
}

/**
 * OAuth token response from provider
 */
export interface OAuthTokenResponse {
    access_token: string;
    token_type: string;
    expires_in?: number;
    refresh_token?: string;
    scope?: string;
    id_token?: string; // For OpenID Connect (Google)
}

// ============================================
// GOOGLE OAUTH SPECIFIC TYPES
// ============================================

/**
 * Google OAuth configuration
 */
export interface GoogleOAuthConfig {
    clientId: string;
    clientSecret: string;
    redirectUri: string;
    scope: string[];
}

/**
 * Google user data from ID token
 */
export interface GoogleUserData {
    id: string; // Google's "sub" claim
    email: string;
    verified_email: boolean;
    name: string;
    given_name: string;
    family_name: string;
    picture: string;
}

/**
 * OAuth tokens from Google
 */
export interface OAuthTokens {
    access_token: string;
    refresh_token?: string;
    expires_in?: number;
    id_token?: string;
}


===== src/auth/utils/auth.utils.ts =====
// src/auth/utils/auth.utils.ts

import { randomBytes } from 'crypto';
import { User } from '@prisma/client';

/**
 * Authentication Utility Functions
 * 
 * Common helpers used across auth services
 */

// ============================================
// TOKEN GENERATION
// ============================================

/**
 * Generate a secure random token
 * @param length - Length in bytes (default 32)
 * @returns Hex string token
 */
export function generateRandomToken(length: number = 32): string {
    return randomBytes(length).toString('hex');
}

/**
 * Generate 6-digit OTP code
 * @returns String OTP code (000000-999999)
 */
export function generateOTPCode(): string {
    return Math.floor(100000 + Math.random() * 900000).toString();
}

// ============================================
// TIME UTILITIES
// ============================================

/**
 * Parse time string to milliseconds
 * @param timeStr - Time string (e.g., "24h", "30d", "5m")
 * @returns Milliseconds
 */
export function parseTimeToMs(timeStr: string): number {
    const unit = timeStr.slice(-1);
    const value = parseInt(timeStr.slice(0, -1));

    switch (unit) {
        case 's':
            return value * 1000;
        case 'm':
            return value * 60 * 1000;
        case 'h':
            return value * 60 * 60 * 1000;
        case 'd':
            return value * 24 * 60 * 60 * 1000;
        default:
            throw new Error(`Invalid time format: ${timeStr}`);
    }
}

/**
 * Get expiration date from now
 * @param hours - Hours from now
 * @returns Date object
 */
export function getTokenExpiration(hours: number): Date {
    const expiresAt = new Date();
    expiresAt.setHours(expiresAt.getHours() + hours);
    return expiresAt;
}

/**
 * Check if date is expired
 * @param date - Date to check
 * @returns True if expired
 */
export function isDateExpired(date: Date): boolean {
    return new Date() > date;
}

// ============================================
// USER FORMATTING
// ============================================

/**
 * Format user object for API responses
 * Removes sensitive fields like password
 * ✅ FIXED: Added null check
 */
export function formatUserResponse(user: User | null): any {
    // ✅ Handle null case
    if (!user) {
        return null;
    }

    const {
        password,
        deletedAt,
        ...safeUser
    } = user;

    return safeUser;
}

// ============================================
// IP & USER AGENT SANITIZATION
// ============================================

/**
 * Sanitize IP address (handle IPv6, proxies, etc.)
 */
export function sanitizeIpAddress(ip: string | undefined): string {
    if (!ip) return 'unknown';

    // Remove IPv6 prefix if present
    if (ip.startsWith('::ffff:')) {
        return ip.substring(7);
    }

    // Handle localhost
    if (ip === '::1' || ip === '127.0.0.1') {
        return 'localhost';
    }

    return ip;
}

/**
 * Sanitize user agent string (truncate if too long)
 */
export function sanitizeUserAgent(userAgent: string | undefined): string {
    if (!userAgent) return 'unknown';

    // Truncate to 500 characters
    return userAgent.length > 500
        ? userAgent.substring(0, 500) + '...'
        : userAgent;
}

// ============================================
// DEVICE INFO EXTRACTION
// ============================================

/**
 * Extract device name from user agent
 * @param userAgent - User agent string
 * @returns Human-readable device name
 */
export function extractDeviceName(userAgent: string | undefined): string {
    if (!userAgent) return 'Unknown Device';

    // Browser detection
    const browsers: Record<string, string> = {
        'Chrome': 'Chrome',
        'Firefox': 'Firefox',
        'Safari': 'Safari',
        'Edge': 'Edge',
        'Opera': 'Opera',
    };

    for (const [key, name] of Object.entries(browsers)) {
        if (userAgent.includes(key)) {
            // OS detection
            if (userAgent.includes('Windows')) return `${name} on Windows`;
            if (userAgent.includes('Mac')) return `${name} on Mac`;
            if (userAgent.includes('Linux')) return `${name} on Linux`;
            if (userAgent.includes('Android')) return `${name} on Android`;
            if (userAgent.includes('iPhone') || userAgent.includes('iPad')) {
                return `${name} on iOS`;
            }
            return name;
        }
    }

    return 'Unknown Device';
}

/**
 * Extract device type from user agent
 * @param userAgent - User agent string
 * @returns Device type: 'mobile' | 'tablet' | 'desktop'
 */
export function extractDeviceType(userAgent: string | undefined): string {
    if (!userAgent) return 'unknown';

    if (
        userAgent.includes('Mobile') ||
        userAgent.includes('Android') ||
        userAgent.includes('iPhone')
    ) {
        return 'mobile';
    }

    if (userAgent.includes('iPad') || userAgent.includes('Tablet')) {
        return 'tablet';
    }

    return 'desktop';
}

// ============================================
// VALIDATION HELPERS
// ============================================

/**
 * Validate email format
 */
export function isValidEmail(email: string): boolean {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return emailRegex.test(email);
}

/**
 * Validate phone format (international)
 */
export function isValidPhone(phone: string): boolean {
    // Accept formats: +919876543210, +1234567890
    const phoneRegex = /^\+?[1-9]\d{1,14}$/;
    return phoneRegex.test(phone);
}

/**
 * Extract email domain
 */
export function getEmailDomain(email: string): string {
    return email.split('@')[1]?.toLowerCase() || '';
}

/**
 * Check if email is from allowed company domain
 * For PenTrack: Only @rivedix.com for R-Admin and Pentester
 */
export function isAllowedCompanyDomain(email: string, allowedDomain: string): boolean {
    const domain = getEmailDomain(email);
    return domain === allowedDomain.toLowerCase();
}


===== src/common/common.module.ts =====
// src/common/common.module.ts

import { Global, Module } from '@nestjs/common';
import { HashService } from './services/hash.service';
import { TokenService } from './services/token.service';
import { ResponseBuilder } from './utils/response-builder.util';
import { RequestContextModule } from '@core/context/request-context.module';
import { PrismaModule } from '@core/database/prisma.module';

/**
 * Common Module
 * 
 * Provides shared services and utilities across the entire application
 * Marked as @Global so these services are available everywhere without importing
 */
@Global()
@Module({
    imports: [
        RequestContextModule, // For ResponseBuilder
        PrismaModule, // For TokenService
    ],
    providers: [
        HashService,
        TokenService,
        ResponseBuilder,
    ],
    exports: [
        HashService,
        TokenService,
        ResponseBuilder,
    ],
})
export class CommonModule { }


===== src/common/enums/error-codes.enum.ts =====
// src/common/enums/error-codes.enum.ts

/**
 * Error Codes Enum
 * 
 * Centralized error codes for the entire application
 * Used for machine-readable error identification
 * 
 * Format: CATEGORY_SPECIFIC_ERROR
 * Example: AUTH_INVALID_CREDENTIALS, USER_NOT_FOUND
 */
export enum ErrorCodes {
    // ============================================
    // GENERIC ERRORS
    // ============================================
    BAD_REQUEST = 'BAD_REQUEST',
    UNAUTHORIZED = 'UNAUTHORIZED',
    FORBIDDEN = 'FORBIDDEN',
    NOT_FOUND = 'NOT_FOUND',
    CONFLICT = 'CONFLICT',
    INTERNAL_SERVER_ERROR = 'INTERNAL_SERVER_ERROR',
    VALIDATION_ERROR = 'VALIDATION_ERROR',

    // ============================================
    // AUTHENTICATION ERRORS
    // ============================================
    INVALID_CREDENTIALS = 'INVALID_CREDENTIALS',
    EMAIL_NOT_VERIFIED = 'EMAIL_NOT_VERIFIED',
    EMAIL_ALREADY_VERIFIED = 'EMAIL_ALREADY_VERIFIED',
    ACCOUNT_SUSPENDED = 'ACCOUNT_SUSPENDED',
    ACCOUNT_DELETED = 'ACCOUNT_DELETED',
    SESSION_INVALID = 'SESSION_INVALID',
    SESSION_EXPIRED = 'SESSION_EXPIRED',
    TOKEN_INVALID = 'TOKEN_INVALID',
    TOKEN_EXPIRED = 'TOKEN_EXPIRED',

    // ============================================
    // USER ERRORS
    // ============================================
    USER_NOT_FOUND = 'USER_NOT_FOUND',
    EMAIL_ALREADY_EXISTS = 'EMAIL_ALREADY_EXISTS',
    PHONE_ALREADY_EXISTS = 'PHONE_ALREADY_EXISTS',

    // ============================================
    // OTP ERRORS (PenTrack specific)
    // ============================================
    OTP_INVALID = 'OTP_INVALID',
    OTP_EXPIRED = 'OTP_EXPIRED',
    OTP_MAX_ATTEMPTS = 'OTP_MAX_ATTEMPTS',
    OTP_RATE_LIMIT = 'OTP_RATE_LIMIT',
    OTP_SEND_FAILED = 'OTP_SEND_FAILED',

    // ============================================
    // OAUTH ERRORS (PenTrack specific)
    // ============================================
    OAUTH_INIT_FAILED = 'OAUTH_INIT_FAILED',
    OAUTH_STATE_INVALID = 'OAUTH_STATE_INVALID',
    OAUTH_STATE_EXPIRED = 'OAUTH_STATE_EXPIRED',
    OAUTH_ROLE_MISMATCH = 'OAUTH_ROLE_MISMATCH',
    OAUTH_INVALID_ROLE = 'OAUTH_INVALID_ROLE', // ✅ ADDED
    OAUTH_TOKEN_EXCHANGE_FAILED = 'OAUTH_TOKEN_EXCHANGE_FAILED',
    OAUTH_EMAIL_DOMAIN_BLOCKED = 'OAUTH_EMAIL_DOMAIN_BLOCKED',
    GOOGLE_AUTH_FAILED = 'GOOGLE_AUTH_FAILED',
    GOOGLE_TOKEN_INVALID = 'GOOGLE_TOKEN_INVALID',
    GOOGLE_ID_TOKEN_INVALID = 'GOOGLE_ID_TOKEN_INVALID',

    // ============================================
    // PERMISSION ERRORS
    // ============================================
    INSUFFICIENT_PERMISSIONS = 'INSUFFICIENT_PERMISSIONS',
    ROLE_MISMATCH = 'ROLE_MISMATCH',

    // ============================================
    // FILE UPLOAD ERRORS
    // ============================================
    FILE_TOO_LARGE = 'FILE_TOO_LARGE',
    FILE_TYPE_NOT_ALLOWED = 'FILE_TYPE_NOT_ALLOWED',
    FILE_UPLOAD_FAILED = 'FILE_UPLOAD_FAILED',

    // ============================================
    // RATE LIMITING ERRORS
    // ============================================
    RATE_LIMIT_EXCEEDED = 'RATE_LIMIT_EXCEEDED',

    // ============================================
    // DATABASE ERRORS
    // ============================================
    DATABASE_ERROR = 'DATABASE_ERROR',
    RECORD_NOT_FOUND = 'RECORD_NOT_FOUND',
    DUPLICATE_RECORD = 'DUPLICATE_RECORD',

    // ============================================
    // EMAIL ERRORS
    // ============================================
    EMAIL_SEND_FAILED = 'EMAIL_SEND_FAILED',
    EMAIL_DOMAIN_NOT_ALLOWED = 'EMAIL_DOMAIN_NOT_ALLOWED',

    // ============================================
    // PASSWORD ERRORS
    // ============================================
    PASSWORD_TOO_WEAK = 'PASSWORD_TOO_WEAK',
    PASSWORD_RESET_FAILED = 'PASSWORD_RESET_FAILED',
    PASSWORD_RESET_TOKEN_INVALID = 'PASSWORD_RESET_TOKEN_INVALID',

    // ============================================
    // PROFILE ERRORS
    // ============================================
    PROFILE_NOT_FOUND = 'PROFILE_NOT_FOUND',
    PROFILE_INCOMPLETE = 'PROFILE_INCOMPLETE',

    // ============================================
    // CLIENT/PARTNER/PENTESTER ERRORS (PenTrack specific)
    // ============================================
    CLIENT_NOT_FOUND = 'CLIENT_NOT_FOUND',
    PARTNER_NOT_FOUND = 'PARTNER_NOT_FOUND',
    PENTESTER_NOT_FOUND = 'PENTESTER_NOT_FOUND',
    COMPANY_DOMAIN_MISMATCH = 'COMPANY_DOMAIN_MISMATCH',

    // ============================================
    // PROJECT ERRORS (Future - PenTrack)
    // ============================================
    PROJECT_NOT_FOUND = 'PROJECT_NOT_FOUND',
    PROJECT_ACCESS_DENIED = 'PROJECT_ACCESS_DENIED',

    // ============================================
    // REPORT ERRORS (Future - PenTrack)
    // ============================================
    REPORT_NOT_FOUND = 'REPORT_NOT_FOUND',
    REPORT_UPLOAD_FAILED = 'REPORT_UPLOAD_FAILED',
}


===== src/common/services/hash.service.ts =====
// src/common/services/hash.service.ts
import { Injectable } from '@nestjs/common';
import * as bcrypt from 'bcrypt';
import { createHash } from 'crypto';
import { ConfigService } from '@nestjs/config';

@Injectable()
export class HashService {
    private readonly saltRounds: number;

    constructor(private configService: ConfigService) {
        this.saltRounds = this.configService.get<number>('BCRYPT_ROUNDS') || 10;
    }

    /**
     * Hash a plain text password using bcrypt
     * bcrypt generates a different hash each time (due to salt)
     */
    async hashPassword(password: string): Promise<string> {
        return bcrypt.hash(password, this.saltRounds);
    }

    /**
     * Compare plain text password with hashed password
     */
    async comparePassword(
        password: string,
        hashedPassword: string,
    ): Promise<boolean> {
        return bcrypt.compare(password, hashedPassword);
    }

    /**
     * Hash a token using SHA-256 (deterministic hashing)
     * This ensures the same token always produces the same hash
     * Use this for OTP codes, verification tokens, reset tokens, etc.
     */
    hashToken(token: string): string {
        return createHash('sha256').update(token).digest('hex');
    }

    /**
     * Compare plain token with hashed token
     * For SHA-256, we just hash the plain token and compare directly
     */
    compareToken(token: string, hashedToken: string): boolean {
        const hashedInput = this.hashToken(token);
        return hashedInput === hashedToken;
    }
}


===== src/common/services/token.service.ts =====
// src/common/services/token.service.ts
import { PrismaService } from '@core/database/prisma.service';
import { Injectable, BadRequestException } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { randomBytes } from 'crypto';
import * as jwt from 'jsonwebtoken';

@Injectable()
export class TokenService {
    private jwtSecret: string;

    constructor(
        private prisma: PrismaService,
        private configService: ConfigService,
    ) {
        this.jwtSecret = this.configService.get<string>('JWT_SECRET') || 'your-secret-key';
    }

    // ============================================
    // JWT TOKEN METHODS (For Session/WebSocket)
    // ============================================

    /**
     * Decode JWT token (for WebSocket authentication)
     * Returns payload if valid, null if invalid
     */
    decodeToken(token: string): { sub: string; email: string; role: string } | null {
        try {
            const decoded = jwt.verify(token, this.jwtSecret) as any;
            return {
                sub: decoded.sub,
                email: decoded.email,
                role: decoded.role,
            };
        } catch (error) {
            return null;
        }
    }

    /**
     * Create JWT token (for sessions)
     */
    createJwtToken(userId: string, email: string, role: string): string {
        return jwt.sign(
            { sub: userId, email, role },
            this.jwtSecret,
            { expiresIn: '7d' } // 7 days
        );
    }

    // ============================================
    // RANDOM TOKEN GENERATION
    // ============================================

    /**
     * Generate a random secure token
     */
    generateSecureToken(length: number = 32): string {
        return randomBytes(length).toString('hex');
    }
}


===== src/common/types/response.types.ts =====
// src/common/types/response.types.ts

// ============================================
// BASE TYPES
// ============================================

/**
 * Standard metadata included in all responses
 */
export interface IResponseMeta {
    timestamp: string;
    requestId: string;
    path: string;
}

// ============================================
// SUCCESS RESPONSE
// ============================================

/**
 * Standard success response structure
 */
export interface ISuccessResponse<T = any> {
    success: true;
    message?: string;
    data: T;
    meta: IResponseMeta;
}

// ============================================
// ERROR RESPONSE
// ============================================

/**
 * Standard error response structure
 */
export interface IErrorResponse {
    success: false;
    error: {
        code: string;
        message: string;
        statusCode: number;
        details?: any;
    };
    meta: IResponseMeta;
}

// ============================================
// WARNING RESPONSE
// ============================================

/**
 * Response with warning - operation succeeded but with non-critical issues
 */
export interface IWarningResponse<T = any> {
    success: true;
    data: T;
    warning: {
        code: string;
        message: string;
    };
    meta: IResponseMeta;
}

// ============================================
// INFO RESPONSE
// ============================================

/**
 * Response with informational message
 */
export interface IInfoResponse<T = any> {
    success: true;
    data: T;
    info: {
        code: string;
        message: string;
    };
    meta: IResponseMeta;
}

// ============================================
// VALIDATION ERROR
// ============================================

/**
 * Validation error details
 */
export interface IValidationError {
    field: string;
    message: string;
    value?: any;
    constraint?: string;
}

// ============================================
// PAGINATION METADATA
// ============================================

/**
 * Pagination metadata for list endpoints
 */
export interface IPaginationMeta {
    total: number;
    page: number;
    limit: number;
    totalPages: number;
    hasNextPage: boolean;
    hasPreviousPage: boolean;
}

/**
 * Paginated response data structure
 */
export interface IPaginatedData<T> {
    items: T[];
    pagination: IPaginationMeta;
}

// ============================================
// TYPE UNIONS
// ============================================

/**
 * Union of all possible response types
 */
export type ApiResponse<T = any> =
    | ISuccessResponse<T>
    | IErrorResponse
    | IWarningResponse<T>
    | IInfoResponse<T>;

// ============================================
// TYPE GUARDS
// ============================================

/**
 * Type guard to check if response is successful
 */
export function isSuccessResponse<T>(
    response: ApiResponse<T>
): response is ISuccessResponse<T> | IWarningResponse<T> | IInfoResponse<T> {
    return response.success === true;
}

/**
 * Type guard to check if response is an error
 */
export function isErrorResponse(
    response: ApiResponse
): response is IErrorResponse {
    return response.success === false;
}

/**
 * Type guard to check if response has a warning
 */
export function hasWarning<T>(
    response: ApiResponse<T>
): response is IWarningResponse<T> {
    return response.success === true && 'warning' in response;
}

/**
 * Type guard to check if response has info
 */
export function hasInfo<T>(
    response: ApiResponse<T>
): response is IInfoResponse<T> {
    return response.success === true && 'info' in response;
}


===== src/common/utils/response-builder.util.ts =====
// src/common/utils/response-builder.util.ts

import { Injectable } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { RequestContextService } from '@core/context/request-context.service';
import {
    ISuccessResponse,
    IErrorResponse,
    IWarningResponse,
    IInfoResponse,
    IResponseMeta,
    IPaginatedData,
    IPaginationMeta,
} from '@common/types/response.types';

/**
 * Response Builder Utility
 * 
 * Centralized utility for building standardized API responses
 * Automatically handles meta field based on environment configuration
 */
@Injectable()
export class ResponseBuilder {
    private readonly includeMeta: boolean;
    private readonly includeMetaInProduction: boolean;
    private readonly includeRequestId: boolean;
    private readonly includeTimestamp: boolean;
    private readonly includePath: boolean;

    constructor(
        private readonly configService: ConfigService,
        private readonly contextService: RequestContextService,
    ) {
        const nodeEnv = this.configService.get<string>('NODE_ENV', 'development');

        // Default: Include meta in dev/staging, exclude in production
        this.includeMetaInProduction = this.configService.get<string>('INCLUDE_META_IN_PRODUCTION', 'false') === 'true';
        this.includeMeta = nodeEnv !== 'production' || this.includeMetaInProduction;

        // Granular control over meta fields
        this.includeRequestId = this.configService.get<string>('INCLUDE_REQUEST_ID', 'true') === 'true';
        this.includeTimestamp = this.configService.get<string>('INCLUDE_TIMESTAMP', 'true') === 'true';
        this.includePath = this.configService.get<string>('INCLUDE_PATH', nodeEnv !== 'production' ? 'true' : 'false') === 'true';
    }

    // ============================================
    // META BUILDER
    // ============================================

    /**
     * Build meta object based on environment configuration
     * Returns undefined if meta should be excluded
     */
    private buildMeta(path?: string): IResponseMeta | undefined {
        if (!this.includeMeta) {
            return undefined;
        }

        const context = this.contextService.getContext();
        const meta: Partial<IResponseMeta> = {};

        if (this.includeTimestamp) {
            meta.timestamp = new Date().toISOString();
        }

        if (this.includeRequestId && context?.requestId) {
            meta.requestId = context.requestId;
        }

        if (this.includePath && path) {
            meta.path = path;
        }

        if (Object.keys(meta).length === 0) {
            return undefined;
        }

        return meta as IResponseMeta;
    }

    // ============================================
    // SUCCESS RESPONSES
    // ============================================

    /**
     * Build success response
     */
    success<T>(
        data: T,
        message?: string,
        path?: string,
    ): Omit<ISuccessResponse<T>, 'success'> {
        const meta = this.buildMeta(path);

        const response: any = {
            success: true,
            data,
        };

        if (message) {
            response.message = message;
        }

        if (meta) {
            response.meta = meta;
        }

        return response;
    }

    /**
     * Build paginated success response
     */
    paginated<T>(
        items: T[],
        pagination: IPaginationMeta,
        message?: string,
        path?: string,
    ): Omit<ISuccessResponse<IPaginatedData<T>>, 'success'> {
        const data: IPaginatedData<T> = {
            items,
            pagination,
        };

        return this.success(data, message, path);
    }

    // ============================================
    // WARNING RESPONSES
    // ============================================

    /**
     * Build warning response (success with non-critical issues)
     */
    warning<T>(
        data: T,
        warningCode: string,
        warningMessage: string,
        path?: string,
    ): Omit<IWarningResponse<T>, 'success'> {
        const meta = this.buildMeta(path);

        const response: any = {
            success: true,
            data,
            warning: {
                code: warningCode,
                message: warningMessage,
            },
        };

        if (meta) {
            response.meta = meta;
        }

        return response;
    }

    // ============================================
    // INFO RESPONSES
    // ============================================

    /**
     * Build info response (success with additional information)
     */
    info<T>(
        data: T,
        infoCode: string,
        infoMessage: string,
        path?: string,
    ): Omit<IInfoResponse<T>, 'success'> {
        const meta = this.buildMeta(path);

        const response: any = {
            success: true,
            data,
            info: {
                code: infoCode,
                message: infoMessage,
            },
        };

        if (meta) {
            response.meta = meta;
        }

        return response;
    }

    // ============================================
    // ERROR RESPONSES (Used by Exception Filters)
    // ============================================

    /**
     * Build error response
     */
    error(
        code: string,
        message: string,
        statusCode: number,
        path?: string,
        details?: any,
    ): Omit<IErrorResponse, 'success'> {
        const meta = this.buildMeta(path);

        const response: any = {
            success: false,
            error: {
                code,
                message,
                statusCode,
                ...(details && { details }),
            },
        };

        if (meta) {
            response.meta = meta;
        }

        return response;
    }

    // ============================================
    // HELPER METHODS
    // ============================================

    /**
     * Check if meta should be included in responses
     */
    shouldIncludeMeta(): boolean {
        return this.includeMeta;
    }

    /**
     * Get current environment
     */
    getEnvironment(): string {
        return this.configService.get<string>('NODE_ENV', 'development');
    }

    /**
     * Build pagination meta from query params
     */
    buildPaginationMeta(
        total: number,
        page: number,
        limit: number,
    ): IPaginationMeta {
        const totalPages = Math.ceil(total / limit);

        return {
            total,
            page,
            limit,
            totalPages,
            hasNextPage: page < totalPages,
            hasPreviousPage: page > 1,
        };
    }
}


===== src/core/filters/global-exception.filter.ts =====
// src/core/filters/global-exception.filter.ts

import {
    ExceptionFilter,
    Catch,
    ArgumentsHost,
    HttpException,
    HttpStatus,
} from '@nestjs/common';
import { Request, Response } from 'express';
import { AppLogger } from '@core/logger/logger.service';
import { RequestContextService } from '@core/context/request-context.service';
import { ResponseBuilder } from '@common/utils/response-builder.util';
import { ErrorCodes } from '@common/enums/error-codes.enum';

/**
 * Global Exception Filter
 * 
 * Catches ALL exceptions in the application and formats them into standardized error responses
 * Handles both HTTP exceptions and unexpected errors
 * Logs errors with context for debugging
 */
@Catch()
export class GlobalExceptionFilter implements ExceptionFilter {
    constructor(
        private readonly logger: AppLogger,
        private readonly contextService: RequestContextService,
        private readonly responseBuilder: ResponseBuilder,
    ) { }

    catch(exception: any, host: ArgumentsHost) {
        const ctx = host.switchToHttp();
        const response = ctx.getResponse<Response>();
        const request = ctx.getRequest<Request>();

        // Get request context
        const context = this.contextService.getContext();
        const requestId = context?.requestId || 'unknown';

        // Determine status code
        const status =
            exception instanceof HttpException
                ? exception.getStatus()
                : HttpStatus.INTERNAL_SERVER_ERROR;

        // Extract error details
        let errorCode: string;
        let errorMessage: string;
        let errorDetails: any = undefined;

        if (exception instanceof HttpException) {
            const exceptionResponse = exception.getResponse();

            if (typeof exceptionResponse === 'object') {
                const responseObj = exceptionResponse as any;
                errorCode = responseObj.code || this.getDefaultErrorCode(status);
                errorMessage = responseObj.message || exception.message;
                errorDetails = responseObj.details;
            } else {
                errorCode = this.getDefaultErrorCode(status);
                errorMessage = exceptionResponse as string;
            }
        } else {
            errorCode = ErrorCodes.INTERNAL_SERVER_ERROR;
            errorMessage = 'An unexpected error occurred. Please try again later.';
        }

        // Log error
        this.logger.error(
            `[${requestId}] ${request.method} ${request.url} - ${status} ${errorCode}: ${errorMessage}`,
            exception.stack,
            'GlobalExceptionFilter',
        );

        // Send standardized error response
        response.status(status).json(
            this.responseBuilder.error(
                errorCode,
                errorMessage,
                status,
                request.url,
                errorDetails,
            ),
        );
    }

    /**
     * Get default error code based on HTTP status
     */
    private getDefaultErrorCode(status: number): string {
        switch (status) {
            case HttpStatus.BAD_REQUEST:
                return ErrorCodes.BAD_REQUEST;
            case HttpStatus.UNAUTHORIZED:
                return ErrorCodes.UNAUTHORIZED;
            case HttpStatus.FORBIDDEN:
                return ErrorCodes.FORBIDDEN;
            case HttpStatus.NOT_FOUND:
                return ErrorCodes.NOT_FOUND;
            case HttpStatus.CONFLICT:
                return ErrorCodes.CONFLICT;
            case HttpStatus.INTERNAL_SERVER_ERROR:
                return ErrorCodes.INTERNAL_SERVER_ERROR;
            default:
                return 'UNKNOWN_ERROR';
        }
    }
}


