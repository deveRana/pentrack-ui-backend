===== prisma/schema.prisma =====
// ==========================
// Generator & Datasource
// ==========================
generator client {
    provider = "prisma-client-js"
}

datasource db {
    provider = "postgresql"
    url      = env("DATABASE_URL")
}

// ==========================
// ENUMS
// ==========================

enum UserRole {
    ADMIN // super_admin in frontend
    R_ADMIN // r-admin in frontend
    PENTESTER // pentester in frontend
    CLIENT // client in frontend
    PARTNER // partner in frontend
}

enum AccountStatus {
    ACTIVE // 'active' in frontend
    INACTIVE // 'inactive' in frontend
    PENDING // Account created but not verified/activated
    SUSPENDED // Temporarily disabled by admin
    DELETED // Soft deleted
}

enum OTPType {
    LOGIN // For login authentication
    SIGNUP // For email verification during signup
}

enum OAuthProviderType {
    GOOGLE
    MICROSOFT // Future support
}

// ==========================
// USER MODEL (Base for all roles)
// ==========================

model User {
    id    String @id @default(uuid())
    email String @unique

    // Password field (NOT USED - all auth is OTP or OAuth)
    password String? // Always NULL for this system

    // Basic Info
    firstName String
    lastName  String
    phone     String @unique // Format: +91XXXXXXXXXX

    // Role & Status
    role   UserRole
    status AccountStatus @default(PENDING)

    // Company Info (Only for R_ADMIN and PENTESTER)
    companyEmail  String? // e.g., rana@rivedix.com
    companyDomain String? // e.g., rivedix.com

    // Profile Image
    profileImage String? // S3 URL or local path

    // Additional fields based on role (will be in separate tables)
    // See Client, Partner, Pentester models below

    // Email Verification
    isEmailVerified Boolean   @default(false)
    emailVerifiedAt DateTime?

    // Login Tracking
    lastLogin   DateTime?
    lastLoginIp String?

    // Timestamps
    createdAt DateTime  @default(now())
    updatedAt DateTime  @updatedAt
    deletedAt DateTime? // Soft delete

    // Relations
    sessions       Session[]
    otpCodes       OTPCode[]
    oauthProviders OAuthProvider[]

    // Audit logs
    auditLogs AuthAuditLog[]

    // Role-specific relations
    createdRAdmins User[]  @relation("AdminCreatedRAdmins")
    createdBy      User?   @relation("AdminCreatedRAdmins", fields: [createdById], references: [id])
    createdById    String?

    createdPentesters User[]  @relation("RAdminCreatedPentesters")
    createdByRAdmin   User?   @relation("RAdminCreatedPentesters", fields: [createdByRAdminId], references: [id])
    createdByRAdminId String?

    // Extended profile relations
    clientProfile    Client?
    partnerProfile   Partner?
    pentesterProfile Pentester?

    @@index([email])
    @@index([role])
    @@index([status])
    @@index([companyDomain])
    @@index([phone])
    @@map("users")
}

// ==========================
// SESSION MODEL (For all logged-in users)
// ==========================

model Session {
    id         String   @id @default(uuid())
    userId     String
    token      String   @unique // Random secure token (stored in HTTP-only cookie)
    expiresAt  DateTime
    rememberMe Boolean  @default(false)

    // Security Tracking
    userAgent    String?  @db.Text
    ipAddress    String?
    lastActivity DateTime @default(now())

    // Device Info (for "Active Sessions" feature)
    deviceName String? // e.g., "Chrome on Windows"
    deviceType String? // e.g., "desktop", "mobile"

    // Timestamps
    createdAt DateTime @default(now())

    // Relations
    user User @relation(fields: [userId], references: [id], onDelete: Cascade)

    @@index([token])
    @@index([userId])
    @@index([expiresAt])
    @@index([userId, expiresAt])
    @@map("sessions")
}

// ==========================
// OTP MODEL (For OTP-based authentication)
// ==========================

model OTPCode {
    id     String  @id @default(uuid())
    userId String? // NULL if user doesn't exist yet (signup flow)
    email  String // Email where OTP is sent
    code   String // 6-digit code (MUST be hashed before storing!)
    type   OTPType

    // Expiry & Usage
    expiresAt DateTime // Typically 10 minutes from creation
    usedAt    DateTime? // Mark as used instead of deleting (audit trail)

    // Rate Limiting Tracking
    attempts Int @default(0) // Track failed verification attempts

    // Timestamps
    createdAt DateTime @default(now())

    // Relations
    user User? @relation(fields: [userId], references: [id], onDelete: Cascade)

    @@index([email])
    @@index([email, type])
    @@index([code])
    @@index([expiresAt])
    @@index([userId])
    @@map("otp_codes")
}

// ==========================
// OAUTH PROVIDER MODEL (For Google OAuth)
// ==========================

model OAuthProvider {
    id         String            @id @default(uuid())
    userId     String
    provider   OAuthProviderType
    providerId String // Unique ID from provider (Google's "sub" claim)

    // Profile Data from Provider
    email   String? // Email from OAuth provider
    name    String? // Full name from OAuth provider
    picture String? // Profile picture URL from OAuth provider

    // Token Storage (optional - for API calls to Google on behalf of user)
    accessToken  String?   @db.Text
    refreshToken String?   @db.Text
    expiresAt    DateTime?

    // Tracking
    linkedAt   DateTime @default(now())
    lastUsedAt DateTime @default(now())

    // Timestamps
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    // Relations
    user User @relation(fields: [userId], references: [id], onDelete: Cascade)

    @@unique([userId, provider])
    @@unique([provider, providerId])
    @@index([userId])
    @@index([provider, providerId])
    @@map("oauth_providers")
}

// ==========================
// CLIENT PROFILE (Extended info for CLIENT role)
// ==========================

model Client {
    id     String @id @default(uuid())
    userId String @unique

    // From ClientProfile type
    clientId    String @unique // Custom client ID (e.g., "CLI-001")
    companyName String
    industry    String
    address     String

    // SPOC (Single Point of Contact) - from frontend types
    pointOfContact      String
    pointOfContactEmail String
    pointOfContactPhone String

    // Optional fields from frontend
    website String?

    // Partner Association (from frontend types)
    hasPartner Boolean @default(false)
    partnerId  String?

    // User Type (from frontend: 'client' | 'partner')
    userType String @default("client") // 'client' or 'partner'

    // Stats (from frontend types)
    totalProjects  Int @default(0)
    activeProjects Int @default(0)

    // Dates (from frontend)
    joinedDate DateTime @default(now())

    // Timestamps
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    // Relations
    user    User     @relation(fields: [userId], references: [id], onDelete: Cascade)
    partner Partner? @relation("PartnerClients", fields: [partnerId], references: [id])

    @@index([userId])
    @@index([companyName])
    @@index([clientId])
    @@index([partnerId])
    @@map("clients")
}

// ==========================
// PARTNER PROFILE (Extended info for PARTNER role)
// ==========================

model Partner {
    id     String @id @default(uuid())
    userId String @unique

    // From Partner type in frontend
    companyName String
    industry    String
    address     String
    website     String?

    // SPOC (from frontend types)
    pointOfContact      String
    pointOfContactEmail String
    pointOfContactPhone String

    // User Type (from frontend: 'client' | 'partner')
    userType String @default("partner")

    // Stats (from frontend types)
    totalProjects  Int @default(0)
    activeProjects Int @default(0)

    // Timestamps
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    // Relations
    user    User     @relation(fields: [userId], references: [id], onDelete: Cascade)
    clients Client[] @relation("PartnerClients") // Clients referred by this partner

    @@index([userId])
    @@index([companyName])
    @@map("partners")
}

// ==========================
// PENTESTER PROFILE (Extended info for PENTESTER role)
// ==========================

model Pentester {
    id     String @id @default(uuid())
    userId String @unique

    // From PentesterProfile type in frontend
    specialization String
    location       String
    bio            String?  @db.Text
    memberSince    DateTime @default(now())

    // Stats (from frontend types)
    totalProjects      Int @default(0)
    completedProjects  Int @default(0)
    inProgressProjects Int @default(0)

    // Timestamps
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    // Relations
    user User @relation(fields: [userId], references: [id], onDelete: Cascade)

    @@index([userId])
    @@index([specialization])
    @@map("pentesters")
}

// ==========================
// AUDIT LOG (Track auth events)
// ==========================

model AuthAuditLog {
    id     String  @id @default(uuid())
    userId String?

    // Event Info
    event       String // "LOGIN_SUCCESS", "LOGIN_FAILED", "OTP_SENT", etc.
    eventType   String // "AUTH", "ACCOUNT", "SECURITY"
    description String? @db.Text

    // Metadata
    metadata Json? // Additional data

    // Tracking
    ipAddress String?
    userAgent String? @db.Text

    // Timestamps
    createdAt DateTime @default(now())

    // Relations
    user User? @relation(fields: [userId], references: [id])

    @@index([userId])
    @@index([event])
    @@index([eventType])
    @@index([createdAt])
    @@map("auth_audit_logs")
}

// ==========================
// ACCOUNT INVITATION (Optional - for invite flow)
// ==========================

model AccountInvitation {
    id        String   @id @default(uuid())
    email     String
    role      UserRole
    invitedBy String // User ID of who sent the invite

    token     String   @unique // Unique token for invitation link
    expiresAt DateTime

    // Status
    status     String    @default("PENDING") // PENDING, ACCEPTED, EXPIRED
    acceptedAt DateTime?

    // Metadata
    metadata Json? // Store additional data (e.g., company info for pentester)

    // Timestamps
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    @@index([email])
    @@index([token])
    @@index([status])
    @@index([expiresAt])
    @@map("account_invitations")
}


===== src/auth/dto/login-otp.dto.ts =====
// src/auth/dto/login-otp.dto.ts
import { IsEmail, IsString, MaxLength } from 'class-validator';

/**
 * DTO for requesting OTP (Step 1 of login)
 * Used by: Admin, Client, Partner
 */
export class RequestOTPDto {
    @IsEmail({}, { message: 'Invalid email format' })
    @MaxLength(255, { message: 'Email must not exceed 255 characters' })
    email: string;
}

/**
 * DTO for verifying OTP and logging in (Step 2 of login)
 * Used by: Admin, Client, Partner
 */
export class VerifyOTPDto {
    @IsEmail({}, { message: 'Invalid email format' })
    @MaxLength(255, { message: 'Email must not exceed 255 characters' })
    email: string;

    @IsString({ message: 'OTP code must be a string' })
    @MaxLength(6, { message: 'OTP code must be 6 characters' })
    code: string;
}


===== src/auth/services/auth.service.ts =====
// src/auth/services/auth.service.ts

import {
    Injectable,
    BadRequestException,
    UnauthorizedException,
    NotFoundException,
} from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { AuthRepository } from '../repositories/auth.repository';
import { OTPService } from './otp.service';
import { SessionService } from './session.service';
import { PrismaService } from '@core/database/prisma.service';
import { User, AccountStatus, UserRole, OTPType } from '@prisma/client';
import { AppLogger } from '@core/logger/logger.service';
import { ErrorCodes } from '@common/enums/error-codes.enum';
import { formatUserResponse } from '../utils/auth.utils';

/**
 * Auth Service
 * Main authentication service for PenTrack
 * 
 * Supports:
 * - OTP-based login (Admin, Client, Partner)
 * - OAuth login (R-Admin, Pentester via Google)
 */
@Injectable()
export class AuthService {
    constructor(
        private readonly authRepository: AuthRepository,
        private readonly otpService: OTPService,
        private readonly sessionService: SessionService,
        private readonly prisma: PrismaService,
        private readonly configService: ConfigService,
        private readonly logger: AppLogger,
    ) { }

    // ============================================
    // OTP LOGIN FLOW
    // ============================================

    /**
     * Step 1: Request OTP (send OTP to email)
     * Used by: Admin, Client, Partner
     */
    async requestOTP(email: string): Promise<{ message: string; expiresIn: number }> {
        // Find user by email
        const user = await this.authRepository.findUserByEmail(email);

        if (!user) {
            throw new NotFoundException({
                code: ErrorCodes.USER_NOT_FOUND,
                message: 'No account found with this email address.',
            });
        }

        // Check if user role is allowed to use OTP login
        if (user.role === UserRole.R_ADMIN || user.role === UserRole.PENTESTER) {
            throw new BadRequestException({
                code: 'OTP_NOT_ALLOWED_FOR_ROLE',
                message: 'R-Admin and Pentester must use Google OAuth to login.',
            });
        }

        // Check account status
        if (user.status === AccountStatus.SUSPENDED) {
            throw new UnauthorizedException(ErrorCodes.ACCOUNT_SUSPENDED);
        }

        if (user.status === AccountStatus.DELETED) {
            throw new UnauthorizedException(ErrorCodes.ACCOUNT_DELETED);
        }

        // Send OTP
        await this.otpService.sendOTP(email, OTPType.LOGIN);

        this.logger.log(`OTP requested for ${email}`, 'AuthService');

        return {
            message: 'OTP sent to your email. It will expire in 10 minutes.',
            expiresIn: 600, // 10 minutes in seconds
        };
    }

    /**
     * Step 2: Verify OTP and login
     * Used by: Admin, Client, Partner
     */
    async verifyOTPAndLogin(
        email: string,
        code: string,
        ipAddress: string,
        userAgent: string,
    ): Promise<{
        user: any;
        sessionToken: string;
    }> {
        // Verify OTP
        const userId = await this.otpService.verifyOTP(email, code, OTPType.LOGIN);

        if (!userId) {
            throw new UnauthorizedException({
                code: ErrorCodes.OTP_INVALID,
                message: 'Invalid OTP code.',
            });
        }

        // Get user
        const user = await this.authRepository.findUserById(userId);

        if (!user) {
            throw new NotFoundException(ErrorCodes.USER_NOT_FOUND);
        }

        // Check account status
        if (user.status !== AccountStatus.ACTIVE) {
            throw new UnauthorizedException(ErrorCodes.ACCOUNT_SUSPENDED);
        }

        // Update last login
        await this.authRepository.updateLastLogin(user.id, ipAddress);

        // Create session
        const sessionToken = await this.sessionService.createSession(
            user.id,
            false, // No "remember me" for OTP login
            userAgent,
            ipAddress,
        );

        this.logger.log(`User logged in via OTP: ${user.email}`, 'AuthService');

        return {
            user: formatUserResponse(user),
            sessionToken,
        };
    }

    // ============================================
    // SESSION VALIDATION
    // ============================================

    /**
     * Validate session token and return user
     */
    async validateSession(sessionToken: string): Promise<User> {
        const session = await this.authRepository.findSessionByToken(sessionToken);

        if (!session) {
            throw new UnauthorizedException(ErrorCodes.SESSION_INVALID);
        }

        // Check if session is expired
        if (new Date() > session.expiresAt) {
            await this.authRepository.deleteSession(sessionToken);
            throw new UnauthorizedException(ErrorCodes.SESSION_EXPIRED);
        }

        // Check if user account is active
        if (session.user.status !== AccountStatus.ACTIVE) {
            throw new UnauthorizedException(ErrorCodes.ACCOUNT_SUSPENDED);
        }

        // Update last activity (rolling session)
        await this.authRepository.updateSessionActivity(session.id);

        return session.user;
    }

    // ============================================
    // GET CURRENT USER
    // ============================================

    /**
     * Get current authenticated user with relations
     */
    async getCurrentUser(userId: string) {
        const user = await this.prisma.user.findUnique({
            where: { id: userId },
            include: {
                clientProfile: true,
                partnerProfile: true,
                pentesterProfile: true,
            },
        });

        if (!user) {
            throw new NotFoundException(ErrorCodes.USER_NOT_FOUND);
        }

        return formatUserResponse(user);
    }

    // ============================================
    // LOGOUT
    // ============================================

    /**
     * Logout user and delete session
     */
    async logout(sessionToken: string) {
        await this.authRepository.deleteSession(sessionToken);

        return {
            message: 'Logout successful',
        };
    }

    /**
     * Logout from all devices
     */
    async logoutFromAllDevices(userId: string) {
        await this.authRepository.deleteAllUserSessions(userId);

        return {
            message: 'Logged out from all devices successfully',
        };
    }
}


===== src/auth/controllers/auth.controller.ts =====
// src/auth/controllers/auth.controller.ts

import {
    Controller,
    Post,
    Get,
    Body,
    Res,
    Req,
    UseGuards,
    HttpCode,
    HttpStatus,
} from '@nestjs/common';
import type { Request, Response } from 'express';
import { AuthService } from '../services/auth.service';
import { TokenService } from '@common/services/token.service';
import { AuthGuard } from '../guards/auth.guard';
import { CurrentUser } from '../decorators/current-user.decorator';
import { Public } from '../decorators/public.decorator';
import type { User } from '@prisma/client';
import { CookieConfig } from '@config/cookie.config';
import { sanitizeIpAddress, sanitizeUserAgent } from '../utils/auth.utils';

/**
 * Auth Controller
 * Handles common auth endpoints (logout, get current user, etc.)
 */
@Controller('auth')
export class AuthController {
    constructor(
        private readonly authService: AuthService,
        private readonly tokenService: TokenService,
    ) { }

    // ============================================
    // GET CURRENT USER
    // ============================================

    /**
     * Get current authenticated user
     * GET /auth/me
     */
    @Get('me')
    @UseGuards(AuthGuard)
    @HttpCode(HttpStatus.OK)
    async getCurrentUser(@CurrentUser() user: User) {
        return await this.authService.getCurrentUser(user.id);
    }

    // ============================================
    // GET WEBSOCKET TOKEN
    // ============================================

    /**
     * Get JWT token for WebSocket authentication
     * GET /auth/ws-token
     */
    @Get('ws-token')
    @UseGuards(AuthGuard)
    @HttpCode(HttpStatus.OK)
    async getWebSocketToken(@CurrentUser() user: User) {
        // Generate JWT token for WebSocket authentication
        const wsToken = this.tokenService.createJwtToken(
            user.id,
            user.email,
            user.role,
        );

        return {
            token: wsToken,
            expiresIn: '7d',
            id: user.id,
            email: user.email,
            firstName: user.firstName,
            lastName: user.lastName,
            role: user.role,
        };
    }

    // ============================================
    // LOGOUT
    // ============================================

    /**
     * Logout user from current device
     * POST /auth/logout
     */
    @Post('logout')
    @UseGuards(AuthGuard)
    @HttpCode(HttpStatus.OK)
    async logout(
        @Req() req: Request,
        @Res({ passthrough: true }) res: Response,
    ) {
        // Get session token from cookie
        const sessionToken = req.cookies[CookieConfig.COOKIE_NAMES.SESSION];

        if (sessionToken) {
            // Delete session from database
            await this.authService.logout(sessionToken);
        }

        // Clear cookie
        res.clearCookie(
            CookieConfig.COOKIE_NAMES.SESSION,
            CookieConfig.getClearCookieOptions(),
        );

        return {
            message: 'Logout successful',
        };
    }

    // ============================================
    // LOGOUT FROM ALL DEVICES
    // ============================================

    /**
     * Logout user from all devices
     * POST /auth/logout-all
     */
    @Post('logout-all')
    @UseGuards(AuthGuard)
    @HttpCode(HttpStatus.OK)
    async logoutFromAllDevices(
        @CurrentUser() user: User,
        @Res({ passthrough: true }) res: Response,
    ) {
        // Delete all sessions for this user
        await this.authService.logoutFromAllDevices(user.id);

        // Clear cookie
        res.clearCookie(
            CookieConfig.COOKIE_NAMES.SESSION,
            CookieConfig.getClearCookieOptions(),
        );

        return {
            message: 'Logged out from all devices successfully',
        };
    }
}


===== src/auth/repositories/auth.repository.ts =====
// src/auth/repositories/auth.repository.ts

import { Injectable } from '@nestjs/common';
import { PrismaService } from '@core/database/prisma.service';
import { User, UserRole, AccountStatus } from '@prisma/client';

/**
 * Auth Repository
 * Handles all database queries related to authentication
 */
@Injectable()
export class AuthRepository {
    constructor(private readonly prisma: PrismaService) { }

    // ============================================
    // USER QUERIES
    // ============================================

    /**
     * Find user by email
     */
    async findUserByEmail(email: string): Promise<User | null> {
        return this.prisma.user.findUnique({
            where: { email },
        });
    }

    /**
     * Find user by ID (with relations based on role)
     */
    async findUserById(userId: string): Promise<User | null> {
        return this.prisma.user.findUnique({
            where: { id: userId },
            include: {
                clientProfile: true,
                partnerProfile: true,
                pentesterProfile: true,
            },
        });
    }

    /**
     * Find user by phone
     */
    async findUserByPhone(phone: string): Promise<User | null> {
        return this.prisma.user.findUnique({
            where: { phone },
        });
    }

    // ============================================
    // USER MUTATIONS
    // ============================================

    /**
     * Create new user
     */
    async createUser(data: {
        email: string;
        password?: string | null;
        firstName: string;
        lastName: string;
        phone: string;
        role: UserRole;
        companyEmail?: string | null;
        companyDomain?: string | null;
    }): Promise<User> {
        return this.prisma.user.create({
            data: {
                email: data.email,
                password: data.password,
                firstName: data.firstName,
                lastName: data.lastName,
                phone: data.phone,
                role: data.role,
                companyEmail: data.companyEmail,
                companyDomain: data.companyDomain,
                status: AccountStatus.PENDING, // Email not verified yet
                isEmailVerified: false,
            },
        });
    }

    /**
     * Update user email verification status
     */
    async markEmailAsVerified(userId: string): Promise<User> {
        return this.prisma.user.update({
            where: { id: userId },
            data: {
                isEmailVerified: true,
                emailVerifiedAt: new Date(),
                status: AccountStatus.ACTIVE, // Account becomes active after verification
            },
        });
    }

    /**
     * Update last login details
     */
    async updateLastLogin(userId: string, ipAddress: string): Promise<User> {
        return this.prisma.user.update({
            where: { id: userId },
            data: {
                lastLogin: new Date(),
                lastLoginIp: ipAddress,
            },
        });
    }

    /**
     * Update account status
     */
    async updateAccountStatus(userId: string, status: AccountStatus): Promise<User> {
        return this.prisma.user.update({
            where: { id: userId },
            data: { status },
        });
    }

    // ============================================
    // SESSION QUERIES
    // ============================================

    /**
     * Find session by token
     */
    async findSessionByToken(token: string) {
        return this.prisma.session.findUnique({
            where: { token },
            include: { user: true },
        });
    }

    /**
     * Find all sessions for a user
     */
    async findUserSessions(userId: string) {
        return this.prisma.session.findMany({
            where: { userId },
            orderBy: { createdAt: 'desc' },
        });
    }

    // ============================================
    // SESSION MUTATIONS
    // ============================================

    /**
     * Create new session
     */
    async createSession(data: {
        userId: string;
        token: string;
        expiresAt: Date;
        rememberMe: boolean;
        userAgent?: string;
        ipAddress?: string;
    }) {
        return this.prisma.session.create({
            data: {
                userId: data.userId,
                token: data.token,
                expiresAt: data.expiresAt,
                rememberMe: data.rememberMe,
                userAgent: data.userAgent,
                ipAddress: data.ipAddress,
            },
        });
    }

    /**
     * Update session last activity
     */
    async updateSessionActivity(sessionId: string) {
        return this.prisma.session.update({
            where: { id: sessionId },
            data: { lastActivity: new Date() },
        });
    }

    /**
     * Delete session by token (logout)
     */
    async deleteSession(token: string): Promise<void> {
        await this.prisma.session.delete({
            where: { token },
        });
    }

    /**
     * Delete all sessions for a user (logout from all devices)
     */
    async deleteAllUserSessions(userId: string): Promise<void> {
        await this.prisma.session.deleteMany({
            where: { userId },
        });
    }

    /**
     * Delete expired sessions (cleanup job)
     */
    async deleteExpiredSessions(): Promise<number> {
        const result = await this.prisma.session.deleteMany({
            where: {
                expiresAt: {
                    lt: new Date(),
                },
            },
        });
        return result.count;
    }
}


===== src/auth/guards/roles.guard.ts =====
// src/auth/guards/roles.guard.ts

import {
    Injectable,
    CanActivate,
    ExecutionContext,
    ForbiddenException,
} from '@nestjs/common';
import { Reflector } from '@nestjs/core';
import { UserRole } from '@prisma/client';
import { ROLES_KEY } from '../decorators/roles.decorator';
import { IS_PUBLIC_KEY } from '../decorators/public.decorator';

/**
 * Roles Guard
 * Enforces role-based access control
 */
@Injectable()
export class RolesGuard implements CanActivate {
    constructor(private readonly reflector: Reflector) { }

    canActivate(context: ExecutionContext): boolean {
        // Check if route is marked as public
        const isPublic = this.reflector.getAllAndOverride<boolean>(IS_PUBLIC_KEY, [
            context.getHandler(),
            context.getClass(),
        ]);

        if (isPublic) {
            return true;
        }

        // Get required roles from decorator
        const requiredRoles = this.reflector.getAllAndOverride<UserRole[]>(
            ROLES_KEY,
            [context.getHandler(), context.getClass()],
        );

        // If no roles are required, allow access
        if (!requiredRoles || requiredRoles.length === 0) {
            return true;
        }

        // Get user from request (attached by AuthGuard)
        const request = context.switchToHttp().getRequest();
        const user = request.user;

        if (!user) {
            throw new ForbiddenException('User not found in request');
        }

        // Check if user has required role
        const hasRole = requiredRoles.includes(user.role);

        if (!hasRole) {
            throw new ForbiddenException(
                `Access denied. Required role(s): ${requiredRoles.join(', ')}`,
            );
        }

        return true;
    }
}


===== src/common/types/response.types.ts =====
// src/common/types/response.types.ts

// ============================================
// BASE TYPES
// ============================================

/**
 * Standard metadata included in all responses
 */
export interface IResponseMeta {
    timestamp: string;
    requestId: string;
    path: string;
}

// ============================================
// SUCCESS RESPONSE
// ============================================

/**
 * Standard success response structure
 */
export interface ISuccessResponse<T = any> {
    success: true;
    message?: string;
    data: T;
    meta: IResponseMeta;
}

// ============================================
// ERROR RESPONSE
// ============================================

/**
 * Standard error response structure
 */
export interface IErrorResponse {
    success: false;
    error: {
        code: string;
        message: string;
        statusCode: number;
        details?: any;
    };
    meta: IResponseMeta;
}

// ============================================
// WARNING RESPONSE
// ============================================

/**
 * Response with warning - operation succeeded but with non-critical issues
 */
export interface IWarningResponse<T = any> {
    success: true;
    data: T;
    warning: {
        code: string;
        message: string;
    };
    meta: IResponseMeta;
}

// ============================================
// INFO RESPONSE
// ============================================

/**
 * Response with informational message
 */
export interface IInfoResponse<T = any> {
    success: true;
    data: T;
    info: {
        code: string;
        message: string;
    };
    meta: IResponseMeta;
}

// ============================================
// VALIDATION ERROR
// ============================================

/**
 * Validation error details
 */
export interface IValidationError {
    field: string;
    message: string;
    value?: any;
    constraint?: string;
}

// ============================================
// PAGINATION METADATA
// ============================================

/**
 * Pagination metadata for list endpoints
 */
export interface IPaginationMeta {
    total: number;
    page: number;
    limit: number;
    totalPages: number;
    hasNextPage: boolean;
    hasPreviousPage: boolean;
}

/**
 * Paginated response data structure
 */
export interface IPaginatedData<T> {
    items: T[];
    pagination: IPaginationMeta;
}

// ============================================
// TYPE UNIONS
// ============================================

/**
 * Union of all possible response types
 */
export type ApiResponse<T = any> =
    | ISuccessResponse<T>
    | IErrorResponse
    | IWarningResponse<T>
    | IInfoResponse<T>;

// ============================================
// TYPE GUARDS
// ============================================

/**
 * Type guard to check if response is successful
 */
export function isSuccessResponse<T>(
    response: ApiResponse<T>
): response is ISuccessResponse<T> | IWarningResponse<T> | IInfoResponse<T> {
    return response.success === true;
}

/**
 * Type guard to check if response is an error
 */
export function isErrorResponse(
    response: ApiResponse
): response is IErrorResponse {
    return response.success === false;
}

/**
 * Type guard to check if response has a warning
 */
export function hasWarning<T>(
    response: ApiResponse<T>
): response is IWarningResponse<T> {
    return response.success === true && 'warning' in response;
}

/**
 * Type guard to check if response has info
 */
export function hasInfo<T>(
    response: ApiResponse<T>
): response is IInfoResponse<T> {
    return response.success === true && 'info' in response;
}


===== src/common/utils/response-builder.util.ts =====
// src/common/utils/response-builder.util.ts

import { Injectable } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { RequestContextService } from '@core/context/request-context.service';
import {
    ISuccessResponse,
    IErrorResponse,
    IWarningResponse,
    IInfoResponse,
    IResponseMeta,
    IPaginatedData,
    IPaginationMeta,
} from '@common/types/response.types';

/**
 * Response Builder Utility
 * 
 * Centralized utility for building standardized API responses
 * Automatically handles meta field based on environment configuration
 */
@Injectable()
export class ResponseBuilder {
    private readonly includeMeta: boolean;
    private readonly includeMetaInProduction: boolean;
    private readonly includeRequestId: boolean;
    private readonly includeTimestamp: boolean;
    private readonly includePath: boolean;

    constructor(
        private readonly configService: ConfigService,
        private readonly contextService: RequestContextService,
    ) {
        const nodeEnv = this.configService.get<string>('NODE_ENV', 'development');

        // Default: Include meta in dev/staging, exclude in production
        this.includeMetaInProduction = this.configService.get<string>('INCLUDE_META_IN_PRODUCTION', 'false') === 'true';
        this.includeMeta = nodeEnv !== 'production' || this.includeMetaInProduction;

        // Granular control over meta fields
        this.includeRequestId = this.configService.get<string>('INCLUDE_REQUEST_ID', 'true') === 'true';
        this.includeTimestamp = this.configService.get<string>('INCLUDE_TIMESTAMP', 'true') === 'true';
        this.includePath = this.configService.get<string>('INCLUDE_PATH', nodeEnv !== 'production' ? 'true' : 'false') === 'true';
    }

    // ============================================
    // META BUILDER
    // ============================================

    /**
     * Build meta object based on environment configuration
     * Returns undefined if meta should be excluded
     */
    private buildMeta(path?: string): IResponseMeta | undefined {
        if (!this.includeMeta) {
            return undefined;
        }

        const context = this.contextService.getContext();
        const meta: Partial<IResponseMeta> = {};

        if (this.includeTimestamp) {
            meta.timestamp = new Date().toISOString();
        }

        if (this.includeRequestId && context?.requestId) {
            meta.requestId = context.requestId;
        }

        if (this.includePath && path) {
            meta.path = path;
        }

        if (Object.keys(meta).length === 0) {
            return undefined;
        }

        return meta as IResponseMeta;
    }

    // ============================================
    // SUCCESS RESPONSES
    // ============================================

    /**
     * Build success response
     */
    success<T>(
        data: T,
        message?: string,
        path?: string,
    ): Omit<ISuccessResponse<T>, 'success'> {
        const meta = this.buildMeta(path);

        const response: any = {
            success: true,
            data,
        };

        if (message) {
            response.message = message;
        }

        if (meta) {
            response.meta = meta;
        }

        return response;
    }

    /**
     * Build paginated success response
     */
    paginated<T>(
        items: T[],
        pagination: IPaginationMeta,
        message?: string,
        path?: string,
    ): Omit<ISuccessResponse<IPaginatedData<T>>, 'success'> {
        const data: IPaginatedData<T> = {
            items,
            pagination,
        };

        return this.success(data, message, path);
    }

    // ============================================
    // WARNING RESPONSES
    // ============================================

    /**
     * Build warning response (success with non-critical issues)
     */
    warning<T>(
        data: T,
        warningCode: string,
        warningMessage: string,
        path?: string,
    ): Omit<IWarningResponse<T>, 'success'> {
        const meta = this.buildMeta(path);

        const response: any = {
            success: true,
            data,
            warning: {
                code: warningCode,
                message: warningMessage,
            },
        };

        if (meta) {
            response.meta = meta;
        }

        return response;
    }

    // ============================================
    // INFO RESPONSES
    // ============================================

    /**
     * Build info response (success with additional information)
     */
    info<T>(
        data: T,
        infoCode: string,
        infoMessage: string,
        path?: string,
    ): Omit<IInfoResponse<T>, 'success'> {
        const meta = this.buildMeta(path);

        const response: any = {
            success: true,
            data,
            info: {
                code: infoCode,
                message: infoMessage,
            },
        };

        if (meta) {
            response.meta = meta;
        }

        return response;
    }

    // ============================================
    // ERROR RESPONSES (Used by Exception Filters)
    // ============================================

    /**
     * Build error response
     */
    error(
        code: string,
        message: string,
        statusCode: number,
        path?: string,
        details?: any,
    ): Omit<IErrorResponse, 'success'> {
        const meta = this.buildMeta(path);

        const response: any = {
            success: false,
            error: {
                code,
                message,
                statusCode,
                ...(details && { details }),
            },
        };

        if (meta) {
            response.meta = meta;
        }

        return response;
    }

    // ============================================
    // HELPER METHODS
    // ============================================

    /**
     * Check if meta should be included in responses
     */
    shouldIncludeMeta(): boolean {
        return this.includeMeta;
    }

    /**
     * Get current environment
     */
    getEnvironment(): string {
        return this.configService.get<string>('NODE_ENV', 'development');
    }

    /**
     * Build pagination meta from query params
     */
    buildPaginationMeta(
        total: number,
        page: number,
        limit: number,
    ): IPaginationMeta {
        const totalPages = Math.ceil(total / limit);

        return {
            total,
            page,
            limit,
            totalPages,
            hasNextPage: page < totalPages,
            hasPreviousPage: page > 1,
        };
    }
}


===== src/common/enums/error-codes.enum.ts =====
// src/common/enums/error-codes.enum.ts

/**
 * Error Codes Enum
 * 
 * Centralized error codes for the entire application
 * Used for machine-readable error identification
 * 
 * Format: CATEGORY_SPECIFIC_ERROR
 * Example: AUTH_INVALID_CREDENTIALS, USER_NOT_FOUND
 */
export enum ErrorCodes {
    // ============================================
    // GENERIC ERRORS
    // ============================================
    BAD_REQUEST = 'BAD_REQUEST',
    UNAUTHORIZED = 'UNAUTHORIZED',
    FORBIDDEN = 'FORBIDDEN',
    NOT_FOUND = 'NOT_FOUND',
    CONFLICT = 'CONFLICT',
    INTERNAL_SERVER_ERROR = 'INTERNAL_SERVER_ERROR',
    VALIDATION_ERROR = 'VALIDATION_ERROR',

    // ============================================
    // AUTHENTICATION ERRORS
    // ============================================
    INVALID_CREDENTIALS = 'INVALID_CREDENTIALS',
    EMAIL_NOT_VERIFIED = 'EMAIL_NOT_VERIFIED',
    EMAIL_ALREADY_VERIFIED = 'EMAIL_ALREADY_VERIFIED',
    ACCOUNT_SUSPENDED = 'ACCOUNT_SUSPENDED',
    ACCOUNT_DELETED = 'ACCOUNT_DELETED',
    SESSION_INVALID = 'SESSION_INVALID',
    SESSION_EXPIRED = 'SESSION_EXPIRED',
    TOKEN_INVALID = 'TOKEN_INVALID',
    TOKEN_EXPIRED = 'TOKEN_EXPIRED',

    // ============================================
    // USER ERRORS
    // ============================================
    USER_NOT_FOUND = 'USER_NOT_FOUND',
    EMAIL_ALREADY_EXISTS = 'EMAIL_ALREADY_EXISTS',
    PHONE_ALREADY_EXISTS = 'PHONE_ALREADY_EXISTS',

    // ============================================
    // OTP ERRORS (PenTrack specific)
    // ============================================
    OTP_INVALID = 'OTP_INVALID',
    OTP_EXPIRED = 'OTP_EXPIRED',
    OTP_MAX_ATTEMPTS = 'OTP_MAX_ATTEMPTS',
    OTP_RATE_LIMIT = 'OTP_RATE_LIMIT',
    OTP_SEND_FAILED = 'OTP_SEND_FAILED',

    // ============================================
    // OAUTH ERRORS (PenTrack specific)
    // ============================================
    OAUTH_INIT_FAILED = 'OAUTH_INIT_FAILED',
    OAUTH_STATE_INVALID = 'OAUTH_STATE_INVALID',
    OAUTH_STATE_EXPIRED = 'OAUTH_STATE_EXPIRED',
    OAUTH_ROLE_MISMATCH = 'OAUTH_ROLE_MISMATCH',
    OAUTH_INVALID_ROLE = 'OAUTH_INVALID_ROLE', // ✅ ADDED
    OAUTH_TOKEN_EXCHANGE_FAILED = 'OAUTH_TOKEN_EXCHANGE_FAILED',
    OAUTH_EMAIL_DOMAIN_BLOCKED = 'OAUTH_EMAIL_DOMAIN_BLOCKED',
    GOOGLE_AUTH_FAILED = 'GOOGLE_AUTH_FAILED',
    GOOGLE_TOKEN_INVALID = 'GOOGLE_TOKEN_INVALID',
    GOOGLE_ID_TOKEN_INVALID = 'GOOGLE_ID_TOKEN_INVALID',

    // ============================================
    // PERMISSION ERRORS
    // ============================================
    INSUFFICIENT_PERMISSIONS = 'INSUFFICIENT_PERMISSIONS',
    ROLE_MISMATCH = 'ROLE_MISMATCH',

    // ============================================
    // FILE UPLOAD ERRORS
    // ============================================
    FILE_TOO_LARGE = 'FILE_TOO_LARGE',
    FILE_TYPE_NOT_ALLOWED = 'FILE_TYPE_NOT_ALLOWED',
    FILE_UPLOAD_FAILED = 'FILE_UPLOAD_FAILED',

    // ============================================
    // RATE LIMITING ERRORS
    // ============================================
    RATE_LIMIT_EXCEEDED = 'RATE_LIMIT_EXCEEDED',

    // ============================================
    // DATABASE ERRORS
    // ============================================
    DATABASE_ERROR = 'DATABASE_ERROR',
    RECORD_NOT_FOUND = 'RECORD_NOT_FOUND',
    DUPLICATE_RECORD = 'DUPLICATE_RECORD',

    // ============================================
    // EMAIL ERRORS
    // ============================================
    EMAIL_SEND_FAILED = 'EMAIL_SEND_FAILED',
    EMAIL_DOMAIN_NOT_ALLOWED = 'EMAIL_DOMAIN_NOT_ALLOWED',

    // ============================================
    // PASSWORD ERRORS
    // ============================================
    PASSWORD_TOO_WEAK = 'PASSWORD_TOO_WEAK',
    PASSWORD_RESET_FAILED = 'PASSWORD_RESET_FAILED',
    PASSWORD_RESET_TOKEN_INVALID = 'PASSWORD_RESET_TOKEN_INVALID',

    // ============================================
    // PROFILE ERRORS
    // ============================================
    PROFILE_NOT_FOUND = 'PROFILE_NOT_FOUND',
    PROFILE_INCOMPLETE = 'PROFILE_INCOMPLETE',

    // ============================================
    // CLIENT/PARTNER/PENTESTER ERRORS (PenTrack specific)
    // ============================================
    CLIENT_NOT_FOUND = 'CLIENT_NOT_FOUND',
    PARTNER_NOT_FOUND = 'PARTNER_NOT_FOUND',
    PENTESTER_NOT_FOUND = 'PENTESTER_NOT_FOUND',
    COMPANY_DOMAIN_MISMATCH = 'COMPANY_DOMAIN_MISMATCH',

    // ============================================
    // PROJECT ERRORS (Future - PenTrack)
    // ============================================
    PROJECT_NOT_FOUND = 'PROJECT_NOT_FOUND',
    PROJECT_ACCESS_DENIED = 'PROJECT_ACCESS_DENIED',

    // ============================================
    // REPORT ERRORS (Future - PenTrack)
    // ============================================
    REPORT_NOT_FOUND = 'REPORT_NOT_FOUND',
    REPORT_UPLOAD_FAILED = 'REPORT_UPLOAD_FAILED',
}


===== src/core/database/prisma.service.ts =====
// src/prisma/prisma.service.ts
import { Injectable, OnModuleInit, OnModuleDestroy } from '@nestjs/common';
import { PrismaClient } from '@prisma/client';

@Injectable()
export class PrismaService
    extends PrismaClient
    implements OnModuleInit, OnModuleDestroy {
    async onModuleInit() {
        await this.$connect();
        console.log('✅ Connected to PostgreSQL via Prisma');
    }

    async onModuleDestroy() {
        await this.$disconnect();
    }
}


===== src/core/filters/global-exception.filter.ts =====
// src/core/filters/global-exception.filter.ts

import {
    ExceptionFilter,
    Catch,
    ArgumentsHost,
    HttpException,
    HttpStatus,
} from '@nestjs/common';
import { Request, Response } from 'express';
import { AppLogger } from '@core/logger/logger.service';
import { RequestContextService } from '@core/context/request-context.service';
import { ResponseBuilder } from '@common/utils/response-builder.util';
import { ErrorCodes } from '@common/enums/error-codes.enum';

/**
 * Global Exception Filter
 * 
 * Catches ALL exceptions in the application and formats them into standardized error responses
 * Handles both HTTP exceptions and unexpected errors
 * Logs errors with context for debugging
 */
@Catch()
export class GlobalExceptionFilter implements ExceptionFilter {
    constructor(
        private readonly logger: AppLogger,
        private readonly contextService: RequestContextService,
        private readonly responseBuilder: ResponseBuilder,
    ) { }

    catch(exception: any, host: ArgumentsHost) {
        const ctx = host.switchToHttp();
        const response = ctx.getResponse<Response>();
        const request = ctx.getRequest<Request>();

        // Get request context
        const context = this.contextService.getContext();
        const requestId = context?.requestId || 'unknown';

        // Determine status code
        const status =
            exception instanceof HttpException
                ? exception.getStatus()
                : HttpStatus.INTERNAL_SERVER_ERROR;

        // Extract error details
        let errorCode: string;
        let errorMessage: string;
        let errorDetails: any = undefined;

        if (exception instanceof HttpException) {
            const exceptionResponse = exception.getResponse();

            if (typeof exceptionResponse === 'object') {
                const responseObj = exceptionResponse as any;
                errorCode = responseObj.code || this.getDefaultErrorCode(status);
                errorMessage = responseObj.message || exception.message;
                errorDetails = responseObj.details;
            } else {
                errorCode = this.getDefaultErrorCode(status);
                errorMessage = exceptionResponse as string;
            }
        } else {
            errorCode = ErrorCodes.INTERNAL_SERVER_ERROR;
            errorMessage = 'An unexpected error occurred. Please try again later.';
        }

        // Log error
        this.logger.error(
            `[${requestId}] ${request.method} ${request.url} - ${status} ${errorCode}: ${errorMessage}`,
            exception.stack,
            'GlobalExceptionFilter',
        );

        // Send standardized error response
        response.status(status).json(
            this.responseBuilder.error(
                errorCode,
                errorMessage,
                status,
                request.url,
                errorDetails,
            ),
        );
    }

    /**
     * Get default error code based on HTTP status
     */
    private getDefaultErrorCode(status: number): string {
        switch (status) {
            case HttpStatus.BAD_REQUEST:
                return ErrorCodes.BAD_REQUEST;
            case HttpStatus.UNAUTHORIZED:
                return ErrorCodes.UNAUTHORIZED;
            case HttpStatus.FORBIDDEN:
                return ErrorCodes.FORBIDDEN;
            case HttpStatus.NOT_FOUND:
                return ErrorCodes.NOT_FOUND;
            case HttpStatus.CONFLICT:
                return ErrorCodes.CONFLICT;
            case HttpStatus.INTERNAL_SERVER_ERROR:
                return ErrorCodes.INTERNAL_SERVER_ERROR;
            default:
                return 'UNKNOWN_ERROR';
        }
    }
}


===== src/core/interceptors/response.interceptor.ts =====
// src/core/interceptors/response.interceptor.ts

import {
    Injectable,
    NestInterceptor,
    ExecutionContext,
    CallHandler,
} from '@nestjs/common';
import { Observable } from 'rxjs';
import { map } from 'rxjs/operators';
import { ResponseBuilder } from '@common/utils/response-builder.util';

/**
 * Response Interceptor
 * 
 * Automatically wraps all successful responses in a standardized format
 * Handles different response types (success, warning, info)
 * 
 * DOES NOT wrap:
 * - Error responses (handled by exception filters)
 * - Responses that already have success: true/false
 * - File downloads (binary responses)
 */
@Injectable()
export class ResponseInterceptor implements NestInterceptor {
    constructor(private readonly responseBuilder: ResponseBuilder) { }

    intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
        return next.handle().pipe(
            map((data) => {
                // Skip wrapping if data is null/undefined
                if (data === null || data === undefined) {
                    return this.responseBuilder.success(null);
                }

                // Skip wrapping if already in standard format (has 'success' field)
                if (typeof data === 'object' && 'success' in data) {
                    return data;
                }

                // Skip wrapping for file downloads (binary data)
                if (data instanceof Buffer || data instanceof Uint8Array) {
                    return data;
                }

                // Check for warning response
                if (typeof data === 'object' && 'warning' in data) {
                    const { warning, ...rest } = data;
                    return this.responseBuilder.warning(
                        rest,
                        warning.code,
                        warning.message,
                    );
                }

                // Check for info response
                if (typeof data === 'object' && 'info' in data) {
                    const { info, ...rest } = data;
                    return this.responseBuilder.info(
                        rest,
                        info.code,
                        info.message,
                    );
                }

                // Check for message-only response
                if (typeof data === 'object' && 'message' in data && Object.keys(data).length === 1) {
                    return this.responseBuilder.success(null, data.message);
                }

                // Check for data + message response
                if (typeof data === 'object' && 'data' in data && 'message' in data) {
                    return this.responseBuilder.success(data.data, data.message);
                }

                // Default: wrap data in success response
                return this.responseBuilder.success(data);
            }),
        );
    }
}


===== src/app.module.ts =====
// src/app.module.ts
import { Module, NestModule, MiddlewareConsumer } from '@nestjs/common';
import { ConfigModule } from '@nestjs/config';
import { APP_GUARD } from '@nestjs/core';

// Core modules
import { PrismaModule } from '@core/database/prisma.module';
import { LoggerModule } from '@core/logger/logger.module';
import { RequestContextModule } from '@core/context/request-context.module';
import { MailModule } from '@core/mail/mail.module';

// CommonModule - Must be EARLY (before feature modules)
import { CommonModule } from './common/common.module';

// Feature modules
import { AuthModule } from './auth/auth.module';

// Middleware
import { RequestContextMiddleware } from '@core/context/request-context.middleware';
import { LoggerMiddleware } from '@core/logger/logger.middleware';

// Guards
import { AuthGuard } from './auth/guards/auth.guard';
import { RolesGuard } from './auth/guards/roles.guard';

@Module({
  imports: [
    // Environment configuration
    ConfigModule.forRoot({
      isGlobal: true,
      envFilePath: process.env.NODE_ENV === 'production' ? '.env.production' : '.env',
    }),

    // CommonModule MUST BE EARLY - Provides shared services globally
    CommonModule,

    // Core modules
    RequestContextModule,
    LoggerModule,
    PrismaModule,
    MailModule,

    // Feature modules
    AuthModule,
  ],
  controllers: [],
  providers: [
    {
      provide: APP_GUARD,
      useClass: AuthGuard,
    },
    {
      provide: APP_GUARD,
      useClass: RolesGuard,
    },
  ],
})
export class AppModule implements NestModule {
  configure(consumer: MiddlewareConsumer) {
    consumer.apply(RequestContextMiddleware).forRoutes('*');
    consumer.apply(LoggerMiddleware).forRoutes('*');
  }
}


===== src/main.ts =====
// src/main.ts

import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import { AppLogger } from '@core/logger/logger.service';
import { LoggerInterceptor } from '@core/logger/logger.interceptor';
import { GlobalExceptionFilter } from '@core/filters/global-exception.filter';
import { ValidationExceptionFilter } from '@core/filters/validation-exception.filter';
import { ResponseInterceptor } from '@core/interceptors/response.interceptor';
import { TimeoutInterceptor } from '@core/interceptors/timeout.interceptor';
import { RequestContextService } from '@core/context/request-context.service';
import { ResponseBuilder } from '@common/utils/response-builder.util';
import {
  ValidationPipe,
  BadRequestException,
  ValidationError,
} from '@nestjs/common';
import cookieParser from 'cookie-parser';

/**
 * Flatten nested validation errors into a single array
 */
function flattenValidationErrors(errors: ValidationError[]): string[] {
  const result: string[] = [];
  for (const err of errors) {
    if (err.constraints) {
      result.push(...Object.values(err.constraints));
    }
    if (err.children && err.children.length) {
      result.push(...flattenValidationErrors(err.children));
    }
  }
  return result;
}

/**
 * Bootstrap the NestJS application
 */
async function bootstrap() {
  const app = await NestFactory.create(AppModule, {
    bufferLogs: true,
    cors: false,
  });

  // Get services from DI container
  const logger = app.get(AppLogger);
  const contextService = app.get(RequestContextService);
  const responseBuilder = app.get(ResponseBuilder);

  // Use custom logger
  app.useLogger(logger);

  // ===========================================
  // SECURITY MIDDLEWARES
  // ===========================================

  // Remove framework info from headers
  app.use((req, res, next) => {
    res.removeHeader('X-Powered-By');
    next();
  });

  // Basic security headers (manual implementation until helmet is installed)
  app.use((req, res, next) => {
    res.setHeader('X-Content-Type-Options', 'nosniff');
    res.setHeader('X-Frame-Options', 'DENY');
    res.setHeader('X-XSS-Protection', '1; mode=block');
    res.setHeader('Referrer-Policy', 'no-referrer');
    res.setHeader('Permissions-Policy', 'geolocation=(), camera=(), microphone=()');
    next();
  });

  // ===========================================
  // CORS CONFIGURATION
  // ===========================================

  const allowedOrigins = process.env.CORS_ORIGIN?.split(',').map(origin => origin.trim()) || [
    'http://localhost:3000',
  ];

  logger.log(`Allowed CORS origins: ${allowedOrigins.join(', ')}`, 'Bootstrap');

  app.enableCors({
    origin: (origin, callback) => {
      if (!origin) return callback(null, true);

      if (allowedOrigins.includes(origin) || allowedOrigins.includes('*')) {
        callback(null, true);
      } else {
        logger.warn(`CORS blocked request from origin: ${origin}`, 'CORS');
        callback(new Error('Not allowed by CORS'));
      }
    },
    credentials: true,
    methods: ['GET', 'POST', 'PUT', 'PATCH', 'DELETE', 'OPTIONS'],
    allowedHeaders: [
      'Content-Type',
      'Authorization',
      'X-Request-Id',
      'X-Forwarded-For',
      'Cookie',
      'Accept',
      'Origin',
    ],
    exposedHeaders: [
      'X-Request-Id',
      'Set-Cookie',
    ],
    maxAge: 86400,
    preflightContinue: false,
    optionsSuccessStatus: 204,
  });

  // ===========================================
  // UTILITY MIDDLEWARES
  // ===========================================

  app.use(cookieParser());

  // ===========================================
  // GLOBAL INTERCEPTORS
  // ===========================================

  // Request/Response logger
  app.useGlobalInterceptors(new LoggerInterceptor(logger));

  // Timeout interceptor (30 seconds)
  app.useGlobalInterceptors(new TimeoutInterceptor(30000));

  // Response wrapper with ResponseBuilder
  app.useGlobalInterceptors(new ResponseInterceptor(responseBuilder));

  // ===========================================
  // GLOBAL FILTERS
  // ===========================================

  // Validation errors with ResponseBuilder
  app.useGlobalFilters(
    new ValidationExceptionFilter(logger, contextService, responseBuilder),
  );

  // All other errors with ResponseBuilder
  app.useGlobalFilters(
    new GlobalExceptionFilter(logger, contextService, responseBuilder),
  );

  // ===========================================
  // GLOBAL PIPES
  // ===========================================

  app.useGlobalPipes(
    new ValidationPipe({
      whitelist: true,
      forbidNonWhitelisted: true,
      transform: true,
      transformOptions: {
        enableImplicitConversion: false,
      },
      exceptionFactory: (errors: ValidationError[] = []) => {
        const messages = flattenValidationErrors(errors);
        return new BadRequestException(messages);
      },
    }),
  );

  // ===========================================
  // GRACEFUL SHUTDOWN
  // ===========================================

  process.on('SIGTERM', async () => {
    logger.log('SIGTERM signal received: closing HTTP server', 'Bootstrap');
    await app.close();
    process.exit(0);
  });

  process.on('SIGINT', async () => {
    logger.log('SIGINT signal received: closing HTTP server', 'Bootstrap');
    await app.close();
    process.exit(0);
  });

  // ===========================================
  // START SERVER
  // ===========================================

  const port = process.env.PORT || 4000;
  const host = process.env.HOST || '0.0.0.0';

  await app.listen(port, host);

  logger.log(
    `🚀 PenTrack Backend running on http://${host}:${port}`,
    'Bootstrap',
  );
  logger.log(
    `📝 Environment: ${process.env.NODE_ENV || 'development'}`,
    'Bootstrap',
  );
  logger.log(
    `🔍 Log level: ${process.env.LOG_LEVEL || 'log'}`,
    'Bootstrap',
  );
  logger.log(
    `🍪 Cookie domain: ${process.env.COOKIE_DOMAIN || 'not set (local dev)'}`,
    'Bootstrap',
  );
}

bootstrap().catch((error) => {
  console.error('❌ Failed to start PenTrack application:', error);
  process.exit(1);
});


