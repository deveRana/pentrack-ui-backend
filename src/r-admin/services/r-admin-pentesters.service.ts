// ===== src/r-admin/services/r-admin-pentesters.service.ts =====
import { Injectable, NotFoundException, ConflictException } from '@nestjs/common';
import { RAdminPentestersRepository } from '../repositories/r-admin-pentesters.repository';
import { CreatePentesterDto, UpdatePentesterDto } from '../dto/create-pentester.dto';

@Injectable()
export class RAdminPentestersService {
    constructor(private readonly pentestersRepository: RAdminPentestersRepository) { }

    async findAll(query: any) {
        const { pentesters, total } = await this.pentestersRepository.findAll(query);

        const data = pentesters.map(p => ({
            id: p.id,
            name: `${p.user.firstName} ${p.user.lastName}`,
            email: p.user.email,
            phone: p.user.phone,
            specialization: p.specialization,
            activeProjects: p.inProgressProjects,
            completedProjects: p.completedProjects,
            status: p.user.status.toLowerCase(),
            createdAt: p.createdAt.toISOString()
        }));

        return {
            stats: { total },
            data,
            pagination: {
                page: query.page,
                limit: query.limit,
                total,
                totalPages: Math.ceil(total / query.limit),
                hasNextPage: query.page < Math.ceil(total / query.limit),
                hasPreviousPage: query.page > 1
            }
        };
    }

    async findOne(id: string) {
        const pentester = await this.pentestersRepository.findOne(id);
        if (!pentester) {
            throw new NotFoundException(`Pentester with ID ${id} not found`);
        }

        return {
            id: pentester.id,
            name: `${pentester.user.firstName} ${pentester.user.lastName}`,
            firstName: pentester.user.firstName,
            lastName: pentester.user.lastName,
            email: pentester.user.email,
            phone: pentester.user.phone,
            specialization: pentester.specialization,
            activeProjects: pentester.inProgressProjects,
            completedProjects: pentester.completedProjects,
            status: pentester.user.status.toLowerCase(),
            createdAt: pentester.createdAt.toISOString(),
            updatedAt: pentester.updatedAt.toISOString()
        };
    }

    async create(dto: CreatePentesterDto, createdById: string) {
        // Check if email already exists
        const existingByEmail = await this.pentestersRepository.findByEmail(dto.email);
        if (existingByEmail) {
            throw new ConflictException('A pentester with this email already exists');
        }

        // Check if phone already exists
        const existingByPhone = await this.pentestersRepository.findByPhone(dto.phone);
        if (existingByPhone) {
            throw new ConflictException('A pentester with this phone number already exists');
        }

        return this.pentestersRepository.create(dto, createdById);
    }

    async update(id: string, dto: UpdatePentesterDto) {
        const existing = await this.pentestersRepository.findOne(id);
        if (!existing) {
            throw new NotFoundException(`Pentester with ID ${id} not found`);
        }

        // Check email conflict
        if (dto.email !== existing.user.email) {
            const existingByEmail = await this.pentestersRepository.findByEmail(dto.email);
            if (existingByEmail && existingByEmail.userId !== existing.userId) {
                throw new ConflictException('A pentester with this email already exists');
            }
        }

        // Check phone conflict
        if (dto.phone !== existing.user.phone) {
            const existingByPhone = await this.pentestersRepository.findByPhone(dto.phone);
            if (existingByPhone && existingByPhone.userId !== existing.userId) {
                throw new ConflictException('A pentester with this phone number already exists');
            }
        }

        return this.pentestersRepository.update(id, dto);
    }

    async delete(id: string) {
        const existing = await this.pentestersRepository.findOne(id);
        if (!existing) {
            throw new NotFoundException(`Pentester with ID ${id} not found`);
        }

        return this.pentestersRepository.delete(id);
    }
}
