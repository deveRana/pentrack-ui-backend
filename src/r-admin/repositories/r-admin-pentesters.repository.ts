// ===== src/r-admin/repositories/r-admin-pentesters.repository.ts (UPDATED) =====
import { Injectable } from '@nestjs/common';
import { PrismaService } from '@core/database/prisma.service';
import { AccountStatus } from '@prisma/client';

@Injectable()
export class RAdminPentestersRepository {
    constructor(private readonly prisma: PrismaService) { }

    async findAll(params: { page: number; limit: number; search?: string; status?: string }) {
        const { page, limit, search, status } = params;
        const skip = (page - 1) * limit;

        const where: any = { user: { deletedAt: null } };

        if (search) {
            where.OR = [
                { user: { firstName: { contains: search, mode: 'insensitive' } } },
                { user: { lastName: { contains: search, mode: 'insensitive' } } },
                { user: { email: { contains: search, mode: 'insensitive' } } }
            ];
        }

        if (status && status !== 'all') {
            where.user = {
                ...where.user,
                status: status.toUpperCase() as AccountStatus
            };
        }

        const [pentesters, total] = await Promise.all([
            this.prisma.pentester.findMany({
                where,
                skip,
                take: limit,
                include: { user: true },
                orderBy: { createdAt: 'desc' }
            }),
            this.prisma.pentester.count({ where })
        ]);

        return { pentesters, total };
    }

    async findOne(id: string) {
        return this.prisma.pentester.findUnique({
            where: { id },
            include: { user: true }
        });
    }

    async findByEmail(email: string) {
        return this.prisma.pentester.findFirst({
            where: {
                user: {
                    email,
                    deletedAt: null
                }
            }
        });
    }

    async findByPhone(phone: string) {
        return this.prisma.pentester.findFirst({
            where: {
                user: {
                    phone,
                    deletedAt: null
                }
            }
        });
    }

    async create(data: any, createdById: string) {
        return this.prisma.$transaction(async (tx) => {
            const user = await tx.user.create({
                data: {
                    email: data.email,
                    firstName: data.firstName,
                    lastName: data.lastName,
                    phone: data.phone,
                    role: 'PENTESTER',
                    status: AccountStatus.ACTIVE,
                    isEmailVerified: true,
                    createdByRAdminId: createdById
                }
            });

            return tx.pentester.create({
                data: {
                    userId: user.id,
                    specialization: data.specialization,
                    location: 'Not specified' // Default value
                },
                include: { user: true }
            });
        });
    }

    async update(id: string, data: any) {
        return this.prisma.$transaction(async (tx) => {
            const pentester = await tx.pentester.findUnique({
                where: { id },
                include: { user: true }
            });

            if (!pentester) return null;

            await tx.user.update({
                where: { id: pentester.userId },
                data: {
                    firstName: data.firstName,
                    lastName: data.lastName,
                    phone: data.phone
                }
            });

            return tx.pentester.update({
                where: { id },
                data: {
                    specialization: data.specialization
                },
                include: { user: true }
            });
        });
    }

    async delete(id: string) {
        return this.prisma.$transaction(async (tx) => {
            const pentester = await tx.pentester.findUnique({ where: { id } });
            if (!pentester) return null;

            await tx.user.update({
                where: { id: pentester.userId },
                data: {
                    deletedAt: new Date(),
                    status: AccountStatus.DELETED
                }
            });

            return pentester;
        });
    }
}