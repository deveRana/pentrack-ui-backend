// src/pentester/services/pentester-reports.service.ts

import { Injectable, NotFoundException, BadRequestException } from '@nestjs/common';
import { PentesterReportsRepository } from '../repositories/pentester-reports.repository';
import { PentesterRepository } from '../repositories/pentester.repository';
import { ErrorCodes } from '@common/enums/error-codes.enum';
import { PentesterReportQueryDto } from '../dto/pentester-query.dto';
import { SubmitReportDto, ResubmitReportDto } from '../dto/submit-report.dto';

@Injectable()
export class PentesterReportsService {
    constructor(
        private readonly pentesterReportsRepository: PentesterReportsRepository,
        private readonly pentesterRepository: PentesterRepository,
    ) { }

    async findAll(userId: string, query: PentesterReportQueryDto) {
        const { page = 1, limit = 10, search, status } = query;

        const [{ reports, total }, stats] = await Promise.all([
            this.pentesterReportsRepository.findAllReports({
                pentesterId: userId,
                page,
                limit,
                search,
                status,
            }),
            this.pentesterReportsRepository.getReportsStats(userId),
        ]);

        const data = reports.map((report) => ({
            id: report.id,
            projectName: report.project.name,
            projectId: report.project.id,
            client: report.project.client.companyName,
            service: report.project.serviceCategory?.name || 'N/A',
            version: report.version,
            status: this.mapStatusToFrontend(report.status),
            submittedDate: report.submittedAt.toISOString(),
            reviewedDate: report.reviewedAt?.toISOString() || null,
            reviewedBy: report.reviewer ? `${report.reviewer.firstName} ${report.reviewer.lastName}` : null,
            reviewerEmail: report.reviewer?.email || null,
            rejectionReason: report.rejectionReason,
            fileName: report.fileName,
            fileSize: this.formatFileSize(report.fileSize),
            fileUrl: report.fileUrl,
            submissionNotes: report.submissionNotes,
        }));

        return {
            stats,
            data,
            pagination: {
                page,
                limit,
                total,
                totalPages: Math.ceil(total / limit),
                hasNextPage: page < Math.ceil(total / limit),
                hasPreviousPage: page > 1,
            },
        };
    }

    async findOne(userId: string, reportId: string) {
        const report = await this.pentesterReportsRepository.findReportById(reportId, userId);

        if (!report) {
            throw new NotFoundException({
                code: ErrorCodes.NOT_FOUND,
                message: 'Report not found',
            });
        }

        return {
            id: report.id,
            projectName: report.project.name,
            projectId: report.project.id,
            client: report.project.client.companyName,
            service: report.project.serviceCategory?.name || 'N/A',
            version: report.version,
            status: this.mapStatusToFrontend(report.status),
            submittedDate: report.submittedAt.toISOString(),
            reviewedDate: report.reviewedAt?.toISOString() || null,
            reviewedBy: report.reviewer ? `${report.reviewer.firstName} ${report.reviewer.lastName}` : null,
            reviewerEmail: report.reviewer?.email || null,
            rejectionReason: report.rejectionReason,
            fileName: report.fileName,
            fileSize: this.formatFileSize(report.fileSize),
            fileUrl: report.fileUrl,
            submissionNotes: report.submissionNotes,
        };
    }

    async findDetails(userId: string, reportId: string) {
        const report = await this.pentesterReportsRepository.findReportDetails(reportId, userId);

        if (!report) {
            throw new NotFoundException({
                code: ErrorCodes.NOT_FOUND,
                message: 'Report not found',
            });
        }

        const checksCompleted = report.checks.map((check) => ({
            id: check.id,
            name: check.securityCheck.title,
            completed: check.completed,
        }));

        const history = report.history.map((h) => ({
            id: h.id,
            version: h.version,
            status: this.mapStatusToFrontend(h.status),
            submittedDate: h.submittedDate.toISOString(),
            reviewedDate: h.reviewedDate?.toISOString() || '',
            fileName: h.fileName,
            fileUrl: h.fileUrl,
            rejectionReason: h.rejectionReason,
        }));

        return {
            id: report.id,
            projectName: report.project.name,
            projectId: report.project.id,
            client: report.project.client.companyName,
            service: report.project.serviceCategory?.name || 'N/A',
            version: report.version,
            status: this.mapStatusToFrontend(report.status),
            submittedDate: report.submittedAt.toISOString(),
            reviewedDate: report.reviewedAt?.toISOString() || null,
            reviewedBy: report.reviewer ? `${report.reviewer.firstName} ${report.reviewer.lastName}` : null,
            reviewerEmail: report.reviewer?.email || null,
            rejectionReason: report.rejectionReason,
            fileName: report.fileName,
            fileSize: this.formatFileSize(report.fileSize),
            fileUrl: report.fileUrl,
            submissionNotes: report.submissionNotes,
            checksCompleted,
            history,
        };
    }

    async submitReport(userId: string, dto: SubmitReportDto, file: Express.Multer.File) {
        const latestVersion = await this.pentesterReportsRepository.getLatestReportVersion(dto.projectId);
        const newVersion = latestVersion + 1;

        const report = await this.pentesterReportsRepository.createReport({
            projectId: dto.projectId,
            pentesterId: userId,
            fileName: file.filename,
            fileUrl: `/uploads/reports/${file.filename}`,
            fileSize: file.size,
            fileType: file.mimetype,
            submissionNotes: dto.submissionNotes,
            version: newVersion,
        });

        const checks = {
            executiveSummary: dto.executiveSummary,
            vulnerabilityDetails: dto.vulnerabilityDetails,
            riskRatings: dto.riskRatings,
            remediationSteps: dto.remediationSteps,
            evidenceAttached: dto.evidenceAttached,
        };

        await this.pentesterReportsRepository.createReportChecks(report.id, checks);

        return {
            id: report.id,
            version: report.version,
            message: 'Report submitted successfully',
        };
    }

    private mapStatusToFrontend(status: string): string {
        const statusMap: Record<string, string> = {
            PENDING: 'Under Review',
            UNDER_REVIEW: 'Under Review',
            APPROVED: 'Approved',
            REJECTED: 'Rejected',
            RESUBMITTED: 'Under Review',
        };
        return statusMap[status] || status;
    }

    private formatFileSize(bytes: number): string {
        if (bytes < 1024) return `${bytes} B`;
        if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(2)} KB`;
        return `${(bytes / (1024 * 1024)).toFixed(2)} MB`;
    }
}