// src/pentester/services/pentester-projects.service.ts

import { Injectable, NotFoundException, BadRequestException } from '@nestjs/common';
import { PentesterProjectsRepository } from '../repositories/pentester-projects.repository';
import { PentesterRepository } from '../repositories/pentester.repository';
import { ErrorCodes } from '@common/enums/error-codes.enum';
import { PentesterProjectQueryDto } from '../dto/pentester-query.dto';
import { UpdateProjectStatusDto } from '../dto/submit-report.dto';
import { ProjectStatus } from '@prisma/client';

@Injectable()
export class PentesterProjectsService {
    constructor(
        private readonly pentesterProjectsRepository: PentesterProjectsRepository,
        private readonly pentesterRepository: PentesterRepository,
    ) { }

    async findAll(userId: string, query: PentesterProjectQueryDto) {
        const { page = 1, limit = 10, search, status, service } = query;

        const [{ projects, total }, stats] = await Promise.all([
            this.pentesterProjectsRepository.findAllProjects({
                pentesterId: userId,
                page,
                limit,
                search,
                status,
                service,
            }),
            this.pentesterProjectsRepository.getProjectsStats(userId),
        ]);

        const data = projects.map((project) => ({
            id: project.id,
            name: project.name,
            client: project.client.companyName,
            company: project.client.companyName,
            service: project.serviceCategory?.name || 'N/A',
            status: this.mapStatusToFrontend(project.status),
            priority: this.mapPriorityToFrontend(project.priority),
            startDate: project.startDate?.toISOString() || '',
            endDate: project.endDate?.toISOString() || '',
            daysLeft: this.calculateDaysLeft(project.deadline || project.endDate),
            scope: project.scopeOfWork || '',
            objectives: project.objectives || '',
        }));

        return {
            stats,
            data,
            pagination: {
                page,
                limit,
                total,
                totalPages: Math.ceil(total / limit),
                hasNextPage: page < Math.ceil(total / limit),
                hasPreviousPage: page > 1,
            },
        };
    }

    async findOne(userId: string, projectId: string) {
        const project = await this.pentesterProjectsRepository.findProjectById(projectId, userId);

        if (!project) {
            throw new NotFoundException({
                code: ErrorCodes.NOT_FOUND,
                message: 'Project not found',
            });
        }

        return {
            id: project.id,
            name: project.name,
            client: project.client.companyName,
            company: project.client.companyName,
            email: project.client.user.email,
            phone: project.client.user.phone,
            address: project.client.address,
            service: project.serviceCategory?.name || 'N/A',
            status: this.mapStatusToFrontend(project.status),
            priority: this.mapPriorityToFrontend(project.priority),
            startDate: project.startDate?.toISOString() || '',
            endDate: project.endDate?.toISOString() || '',
            daysLeft: this.calculateDaysLeft(project.deadline || project.endDate),
            scope: project.scopeOfWork || '',
            objectives: project.objectives || '',
            targetUrls: project.targetUrls || '',
            createdBy: project.radmin ? `${project.radmin.firstName} ${project.radmin.lastName}` : 'Unknown',
            createdAt: project.createdAt.toISOString(),
        };
    }

    async updateProjectStatus(userId: string, projectId: string, dto: UpdateProjectStatusDto) {
        const project = await this.pentesterProjectsRepository.findProjectById(projectId, userId);

        if (!project) {
            throw new NotFoundException({
                code: ErrorCodes.NOT_FOUND,
                message: 'Project not found',
            });
        }

        const validStatuses = ['NOT_STARTED', 'IN_PROGRESS', 'TESTING_COMPLETE'];
        if (!validStatuses.includes(dto.status)) {
            throw new BadRequestException({
                code: 'INVALID_STATUS',
                message: 'Invalid project status',
            });
        }

        await this.pentesterProjectsRepository.updateProjectStatus(projectId, userId, dto.status as ProjectStatus);

        return { message: 'Project status updated successfully' };
    }

    async getAvailableForUpload(userId: string) {
        const projects = await this.pentesterProjectsRepository.getAvailableProjectsForUpload(userId);

        return projects.map((project) => ({
            id: project.id,
            name: project.name,
            status: this.mapStatusToFrontend(project.status),
            clientName: project.client.companyName,
            serviceName: project.serviceCategory?.name || 'N/A',
            projectName: project.name,
        }));
    }

    private calculateDaysLeft(date: Date | null): number {
        if (!date) return 0;
        const now = new Date();
        const diff = date.getTime() - now.getTime();
        return Math.ceil(diff / (1000 * 60 * 60 * 24));
    }

    private mapStatusToFrontend(status: string): string {
        const statusMap: Record<string, string> = {
            NOT_STARTED: 'Not Started',
            IN_PROGRESS: 'In Progress',
            TESTING_COMPLETE: 'Testing Complete',
            REPORT_SUBMITTED: 'Report Submitted',
            UNDER_REVIEW: 'Under Review',
            COMPLETED: 'Completed',
            REJECTED: 'Rejected',
        };
        return statusMap[status] || status;
    }

    private mapPriorityToFrontend(priority: string): string {
        return priority.toLowerCase();
    }
}