// src/pentester/services/pentester.service.ts

import { Injectable, NotFoundException } from '@nestjs/common';
import { PentesterRepository } from '../repositories/pentester.repository';
import { ErrorCodes } from '@common/enums/error-codes.enum';
import { UpdatePentesterProfileDto } from '../dto/update-profile.dto';
import {
    PentesterProfileResponse,
    PentesterProfileStats,
    PentesterDashboardResponse,
} from '../types/pentester-response.types';

@Injectable()
export class PentesterService {
    constructor(private readonly pentesterRepository: PentesterRepository) { }

    async getProfile(userId: string): Promise<PentesterProfileResponse> {
        const pentester = await this.pentesterRepository.findPentesterByUserId(userId);

        if (!pentester) {
            throw new NotFoundException({
                code: ErrorCodes.USER_NOT_FOUND,
                message: 'Pentester profile not found',
            });
        }

        return {
            id: pentester.id,
            firstName: pentester.user.firstName,
            lastName: pentester.user.lastName,
            email: pentester.user.email,
            phone: pentester.user.phone,
            specialization: pentester.specialization,
            location: pentester.location,
            bio: pentester.bio || '',
            memberSince: pentester.memberSince.toISOString(),
            status: pentester.user.status,
        };
    }

    async getProfileStats(userId: string): Promise<PentesterProfileStats> {
        return this.pentesterRepository.getProfileStats(userId);
    }

    async updateProfile(userId: string, dto: UpdatePentesterProfileDto): Promise<PentesterProfileResponse> {
        const pentester = await this.pentesterRepository.findPentesterByUserId(userId);

        if (!pentester) {
            throw new NotFoundException({
                code: ErrorCodes.USER_NOT_FOUND,
                message: 'Pentester profile not found',
            });
        }

        const updated = await this.pentesterRepository.updatePentesterProfile(userId, dto);

        return {
            id: updated.id,
            firstName: updated.user.firstName,
            lastName: updated.user.lastName,
            email: updated.user.email,
            phone: updated.user.phone,
            specialization: updated.specialization,
            location: updated.location,
            bio: updated.bio || '',
            memberSince: updated.memberSince.toISOString(),
            status: updated.user.status,
        };
    }

    async getDashboard(userId: string): Promise<PentesterDashboardResponse> {
        const [stats, upcomingDeadlinesData, myProjectsData, recentActivitiesData] = await Promise.all([
            this.pentesterRepository.getDashboardStats(userId),
            this.pentesterRepository.getUpcomingDeadlines(userId),
            this.pentesterRepository.getMyProjects(userId),
            this.pentesterRepository.getRecentActivities(userId),
        ]);

        const upcomingDeadlines = upcomingDeadlinesData.map((project) => ({
            id: project.id,
            projectName: project.name,
            client: project.client.companyName,
            daysLeft: this.calculateDaysLeft(project.deadline),
            status: this.mapStatusToFrontend(project.status),
        }));

        const myProjects = myProjectsData.map((project) => ({
            id: project.id,
            name: project.name,
            client: project.client.companyName,
            service: project.serviceCategory?.name || 'N/A',
            status: this.mapStatusToFrontend(project.status),
            deadline: project.deadline?.toISOString() || '',
            daysLeft: this.calculateDaysLeft(project.deadline),
        }));

        const recentActivities = recentActivitiesData.map((activity) => ({
            id: activity.id,
            type: activity.activityType.toLowerCase(),
            message: activity.description,
            time: this.getRelativeTime(activity.createdAt),
            status: this.mapActivityStatus(activity.activityType),
        }));

        return {
            stats,
            upcomingDeadlines,
            myProjects,
            recentActivities,
        };
    }

    private calculateDaysLeft(deadline: Date | null): number {
        if (!deadline) return 0;
        const now = new Date();
        const diff = deadline.getTime() - now.getTime();
        return Math.ceil(diff / (1000 * 60 * 60 * 24));
    }

    private mapStatusToFrontend(status: string): string {
        const statusMap: Record<string, string> = {
            NOT_STARTED: 'Not Started',
            IN_PROGRESS: 'In Progress',
            TESTING_COMPLETE: 'Testing Complete',
            REPORT_SUBMITTED: 'Report Submitted',
            UNDER_REVIEW: 'Under Review',
            COMPLETED: 'Completed',
            REJECTED: 'Rejected',
        };
        return statusMap[status] || status;
    }

    private mapActivityStatus(activityType: string): string {
        const statusMap: Record<string, string> = {
            CREATED: 'info',
            STATUS_CHANGED: 'info',
            REPORT_SUBMITTED: 'success',
            REPORT_APPROVED: 'success',
            REPORT_REJECTED: 'error',
        };
        return statusMap[activityType] || 'info';
    }

    private getRelativeTime(date: Date): string {
        const now = new Date();
        const diffMs = now.getTime() - date.getTime();
        const diffMins = Math.floor(diffMs / (1000 * 60));
        const diffHours = Math.floor(diffMs / (1000 * 60 * 60));
        const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));

        if (diffMins < 1) return 'Just now';
        if (diffMins < 60) return `${diffMins} minute${diffMins > 1 ? 's' : ''} ago`;
        if (diffHours < 24) return `${diffHours} hour${diffHours > 1 ? 's' : ''} ago`;
        return `${diffDays} day${diffDays > 1 ? 's' : ''} ago`;
    }
}