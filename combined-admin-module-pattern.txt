===== src/auth/auth.module.ts =====
// src/auth/auth.module.ts

import { Module } from '@nestjs/common';
import { JwtModule } from '@nestjs/jwt';
import { ConfigModule, ConfigService } from '@nestjs/config';

// Controllers
import { AuthController } from './controllers/auth.controller';
import { OTPController } from './controllers/otp.controller';
import { OAuthController } from './controllers/oauth.controller';

// Services
import { AuthService } from './services/auth.service';
import { SessionService } from './services/session.service';
import { OTPService } from './services/otp.service';

// OAuth Services
// import { OAuthBaseService } from './services/oauth/oauth-base.service'; // REMOVE THIS IMPORT
import { GoogleOAuthService } from './services/oauth/google-oauth.service';

// Repositories
import { AuthRepository } from './repositories/auth.repository';

// Guards
import { AuthGuard } from './guards/auth.guard';
import { RolesGuard } from './guards/roles.guard';

// Modules
import { CommonModule } from '@common/common.module';
import { MailModule } from '@core/mail/mail.module';
import { LoggerModule } from '@core/logger/logger.module';

@Module({
    imports: [
        CommonModule,
        ConfigModule,
        MailModule,
        LoggerModule,
        JwtModule.registerAsync({
            imports: [ConfigModule],
            inject: [ConfigService],
            useFactory: async (configService: ConfigService) => ({
                secret: configService.get<string>('JWT_SECRET') || 'your-secret-key',
                signOptions: {
                    expiresIn: '7d',
                },
            }),
        }),
    ],
    controllers: [
        AuthController,
        OTPController,
        OAuthController,
    ],
    providers: [
        // Core Services
        AuthService,
        SessionService,
        OTPService,

        // OAuth Services - ONLY concrete implementations
        GoogleOAuthService, // KEEP THIS

        // Repositories
        AuthRepository,

        // Guards
        AuthGuard,
        RolesGuard,
    ],
    exports: [
        AuthService,
        SessionService,
        OTPService,
        AuthGuard,
        RolesGuard,
    ],
})
export class AuthModule { }


===== src/auth/services/auth.service.ts =====
// src/auth/services/auth.service.ts

import {
    Injectable,
    BadRequestException,
    UnauthorizedException,
    NotFoundException,
} from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { AuthRepository } from '../repositories/auth.repository';
import { OTPService } from './otp.service';
import { SessionService } from './session.service';
import { PrismaService } from '@core/database/prisma.service';
import { User, AccountStatus, UserRole, OTPType } from '@prisma/client';
import { AppLogger } from '@core/logger/logger.service';
import { ErrorCodes } from '@common/enums/error-codes.enum';
import { formatUserResponse } from '../utils/auth.utils';

/**
 * Auth Service
 * Main authentication service for PenTrack
 * 
 * Supports:
 * - OTP-based login (Admin, Client, Partner)
 * - OAuth login (R-Admin, Pentester via Google)
 */
@Injectable()
export class AuthService {
    constructor(
        private readonly authRepository: AuthRepository,
        private readonly otpService: OTPService,
        private readonly sessionService: SessionService,
        private readonly prisma: PrismaService,
        private readonly configService: ConfigService,
        private readonly logger: AppLogger,
    ) { }

    // ============================================
    // OTP LOGIN FLOW
    // ============================================

    /**
     * Step 1: Request OTP (send OTP to email)
     * Used by: Admin, Client, Partner
     */
    async requestOTP(email: string): Promise<{ message: string; expiresIn: number }> {
        // Find user by email
        const user = await this.authRepository.findUserByEmail(email);

        if (!user) {
            throw new NotFoundException({
                code: ErrorCodes.USER_NOT_FOUND,
                message: 'No account found with this email address.',
            });
        }

        // Check if user role is allowed to use OTP login
        if (user.role === UserRole.R_ADMIN || user.role === UserRole.PENTESTER) {
            throw new BadRequestException({
                code: 'OTP_NOT_ALLOWED_FOR_ROLE',
                message: 'R-Admin and Pentester must use Google OAuth to login.',
            });
        }

        // Check account status
        if (user.status === AccountStatus.SUSPENDED) {
            throw new UnauthorizedException(ErrorCodes.ACCOUNT_SUSPENDED);
        }

        if (user.status === AccountStatus.DELETED) {
            throw new UnauthorizedException(ErrorCodes.ACCOUNT_DELETED);
        }

        // Send OTP
        await this.otpService.sendOTP(email, OTPType.LOGIN);

        this.logger.log(`OTP requested for ${email}`, 'AuthService');

        return {
            message: 'OTP sent to your email. It will expire in 10 minutes.',
            expiresIn: 600, // 10 minutes in seconds
        };
    }

    /**
     * Step 2: Verify OTP and login
     * Used by: Admin, Client, Partner
     */
    async verifyOTPAndLogin(
        email: string,
        code: string,
        ipAddress: string,
        userAgent: string,
    ): Promise<{
        user: any;
        sessionToken: string;
    }> {
        // Verify OTP
        const userId = await this.otpService.verifyOTP(email, code, OTPType.LOGIN);

        if (!userId) {
            throw new UnauthorizedException({
                code: ErrorCodes.OTP_INVALID,
                message: 'Invalid OTP code.',
            });
        }

        // Get user
        const user = await this.authRepository.findUserById(userId);

        if (!user) {
            throw new NotFoundException(ErrorCodes.USER_NOT_FOUND);
        }

        // Check account status
        if (user.status !== AccountStatus.ACTIVE) {
            throw new UnauthorizedException(ErrorCodes.ACCOUNT_SUSPENDED);
        }

        // Update last login
        await this.authRepository.updateLastLogin(user.id, ipAddress);

        // Create session
        const sessionToken = await this.sessionService.createSession(
            user.id,
            false, // No "remember me" for OTP login
            userAgent,
            ipAddress,
        );

        this.logger.log(`User logged in via OTP: ${user.email}`, 'AuthService');

        return {
            user: formatUserResponse(user),
            sessionToken,
        };
    }

    // ============================================
    // SESSION VALIDATION
    // ============================================

    /**
     * Validate session token and return user
     */
    async validateSession(sessionToken: string): Promise<User> {
        const session = await this.authRepository.findSessionByToken(sessionToken);

        if (!session) {
            throw new UnauthorizedException(ErrorCodes.SESSION_INVALID);
        }

        // Check if session is expired
        if (new Date() > session.expiresAt) {
            await this.authRepository.deleteSession(sessionToken);
            throw new UnauthorizedException(ErrorCodes.SESSION_EXPIRED);
        }

        // Check if user account is active
        if (session.user.status !== AccountStatus.ACTIVE) {
            throw new UnauthorizedException(ErrorCodes.ACCOUNT_SUSPENDED);
        }

        // Update last activity (rolling session)
        await this.authRepository.updateSessionActivity(session.id);

        return session.user;
    }

    // ============================================
    // GET CURRENT USER
    // ============================================

    /**
     * Get current authenticated user with relations
     */
    async getCurrentUser(userId: string) {
        const user = await this.prisma.user.findUnique({
            where: { id: userId },
            include: {
                clientProfile: true,
                partnerProfile: true,
                pentesterProfile: true,
            },
        });

        if (!user) {
            throw new NotFoundException(ErrorCodes.USER_NOT_FOUND);
        }

        return formatUserResponse(user);
    }

    // ============================================
    // LOGOUT
    // ============================================

    /**
     * Logout user and delete session
     */
    async logout(sessionToken: string) {
        await this.authRepository.deleteSession(sessionToken);

        return {
            message: 'Logout successful',
        };
    }

    /**
     * Logout from all devices
     */
    async logoutFromAllDevices(userId: string) {
        await this.authRepository.deleteAllUserSessions(userId);

        return {
            message: 'Logged out from all devices successfully',
        };
    }
}


===== src/auth/repositories/auth.repository.ts =====
// src/auth/repositories/auth.repository.ts

import { Injectable } from '@nestjs/common';
import { PrismaService } from '@core/database/prisma.service';
import { User, UserRole, AccountStatus } from '@prisma/client';

/**
 * Auth Repository
 * Handles all database queries related to authentication
 */
@Injectable()
export class AuthRepository {
    constructor(private readonly prisma: PrismaService) { }

    // ============================================
    // USER QUERIES
    // ============================================

    /**
     * Find user by email
     */
    async findUserByEmail(email: string): Promise<User | null> {
        return this.prisma.user.findUnique({
            where: { email },
        });
    }

    /**
     * Find user by ID (with relations based on role)
     */
    async findUserById(userId: string): Promise<User | null> {
        return this.prisma.user.findUnique({
            where: { id: userId },
            include: {
                clientProfile: true,
                partnerProfile: true,
                pentesterProfile: true,
            },
        });
    }

    /**
     * Find user by phone
     */
    async findUserByPhone(phone: string): Promise<User | null> {
        return this.prisma.user.findUnique({
            where: { phone },
        });
    }

    // ============================================
    // USER MUTATIONS
    // ============================================

    /**
     * Create new user
     */
    async createUser(data: {
        email: string;
        password?: string | null;
        firstName: string;
        lastName: string;
        phone: string;
        role: UserRole;
        companyEmail?: string | null;
        companyDomain?: string | null;
    }): Promise<User> {
        return this.prisma.user.create({
            data: {
                email: data.email,
                password: data.password,
                firstName: data.firstName,
                lastName: data.lastName,
                phone: data.phone,
                role: data.role,
                companyEmail: data.companyEmail,
                companyDomain: data.companyDomain,
                status: AccountStatus.PENDING, // Email not verified yet
                isEmailVerified: false,
            },
        });
    }

    /**
     * Update user email verification status
     */
    async markEmailAsVerified(userId: string): Promise<User> {
        return this.prisma.user.update({
            where: { id: userId },
            data: {
                isEmailVerified: true,
                emailVerifiedAt: new Date(),
                status: AccountStatus.ACTIVE, // Account becomes active after verification
            },
        });
    }

    /**
     * Update last login details
     */
    async updateLastLogin(userId: string, ipAddress: string): Promise<User> {
        return this.prisma.user.update({
            where: { id: userId },
            data: {
                lastLogin: new Date(),
                lastLoginIp: ipAddress,
            },
        });
    }

    /**
     * Update account status
     */
    async updateAccountStatus(userId: string, status: AccountStatus): Promise<User> {
        return this.prisma.user.update({
            where: { id: userId },
            data: { status },
        });
    }

    // ============================================
    // SESSION QUERIES
    // ============================================

    /**
     * Find session by token
     */
    async findSessionByToken(token: string) {
        return this.prisma.session.findUnique({
            where: { token },
            include: { user: true },
        });
    }

    /**
     * Find all sessions for a user
     */
    async findUserSessions(userId: string) {
        return this.prisma.session.findMany({
            where: { userId },
            orderBy: { createdAt: 'desc' },
        });
    }

    // ============================================
    // SESSION MUTATIONS
    // ============================================

    /**
     * Create new session
     */
    async createSession(data: {
        userId: string;
        token: string;
        expiresAt: Date;
        rememberMe: boolean;
        userAgent?: string;
        ipAddress?: string;
    }) {
        return this.prisma.session.create({
            data: {
                userId: data.userId,
                token: data.token,
                expiresAt: data.expiresAt,
                rememberMe: data.rememberMe,
                userAgent: data.userAgent,
                ipAddress: data.ipAddress,
            },
        });
    }

    /**
     * Update session last activity
     */
    async updateSessionActivity(sessionId: string) {
        return this.prisma.session.update({
            where: { id: sessionId },
            data: { lastActivity: new Date() },
        });
    }

    /**
     * Delete session by token (logout)
     */
    async deleteSession(token: string): Promise<void> {
        await this.prisma.session.delete({
            where: { token },
        });
    }

    /**
     * Delete all sessions for a user (logout from all devices)
     */
    async deleteAllUserSessions(userId: string): Promise<void> {
        await this.prisma.session.deleteMany({
            where: { userId },
        });
    }

    /**
     * Delete expired sessions (cleanup job)
     */
    async deleteExpiredSessions(): Promise<number> {
        const result = await this.prisma.session.deleteMany({
            where: {
                expiresAt: {
                    lt: new Date(),
                },
            },
        });
        return result.count;
    }
}


===== src/auth/dto/login-otp.dto.ts =====
// src/auth/dto/login-otp.dto.ts
import { IsEmail, IsString, MaxLength } from 'class-validator';

/**
 * DTO for requesting OTP (Step 1 of login)
 * Used by: Admin, Client, Partner
 */
export class RequestOTPDto {
    @IsEmail({}, { message: 'Invalid email format' })
    @MaxLength(255, { message: 'Email must not exceed 255 characters' })
    email: string;
}

/**
 * DTO for verifying OTP and logging in (Step 2 of login)
 * Used by: Admin, Client, Partner
 */
export class VerifyOTPDto {
    @IsEmail({}, { message: 'Invalid email format' })
    @MaxLength(255, { message: 'Email must not exceed 255 characters' })
    email: string;

    @IsString({ message: 'OTP code must be a string' })
    @MaxLength(6, { message: 'OTP code must be 6 characters' })
    code: string;
}


===== src/auth/types/auth-response.types.ts =====
// src/auth/types/auth-response.types.ts

/**
 * User response structure (matches frontend UserProfile types)
 */
export interface UserResponse {
    id: string;
    email: string;
    firstName: string;
    lastName: string;
    phone: string;
    role: 'ADMIN' | 'R_ADMIN' | 'PENTESTER' | 'CLIENT' | 'PARTNER';
    status: 'ACTIVE' | 'INACTIVE' | 'PENDING' | 'SUSPENDED' | 'DELETED';
    isEmailVerified: boolean;
    profileImage?: string | null;
    companyEmail?: string | null;
    companyDomain?: string | null;

    // Extended profile data based on role
    clientProfile?: any;
    partnerProfile?: any;
    pentesterProfile?: any;
}

/**
 * Base response structure
 */
export interface BaseResponse {
    success: boolean;
    message: string;
}

/**
 * OTP request response
 */
export interface RequestOTPResponse extends BaseResponse {
    expiresIn: number; // Seconds until OTP expires
}

/**
 * Login response (after OTP verification or OAuth)
 */
export interface LoginResponse extends BaseResponse {
    user: UserResponse;
}

/**
 * Get current user response
 */
export interface GetMeResponse {
    success: boolean;
    user: UserResponse;
}


===== src/admin/admin.module.ts =====
// src/admin/admin.module.ts

import { Module } from '@nestjs/common';
import { PrismaModule } from '@core/database/prisma.module';
import { MailModule } from '@core/mail/mail.module';
import { LoggerModule } from '@core/logger/logger.module';
import { AuthModule } from '@auth/auth.module'; // ✅ ADDED: Import AuthModule for guards

// Controllers
import { AdminController } from './controllers/admin.controller';
import { RAdminController } from './controllers/radmin.controller';
import { SystemLogsController } from './controllers/system-logs.controller';

// Services
import { AdminService } from './services/admin.service';
import { RAdminService } from './services/radmin.service';
import { SystemLogsService } from './services/system-logs.service';

// Repositories
import { AdminRepository } from './repositories/admin.repository';
import { RAdminRepository } from './repositories/radmin.repository';
import { SystemLogsRepository } from './repositories/system-logs.repository';

/**
 * Admin Module
 * 
 * Handles all Super Admin operations:
 * - Admin profile management
 * - Admin dashboard
 * - R-Admin CRUD operations
 * - System logs viewing and export
 * 
 * Routes:
 * - GET    /admin/profile          - Get admin profile
 * - PUT    /admin/profile          - Update admin profile
 * - GET    /admin/dashboard        - Get dashboard data
 * - GET    /admin/r-admins         - List all R-Admins
 * - GET    /admin/r-admins/stats   - Get R-Admin statistics
 * - GET    /admin/r-admins/:id     - Get R-Admin by ID
 * - POST   /admin/r-admins         - Create R-Admin
 * - PUT    /admin/r-admins/:id     - Update R-Admin
 * - DELETE /admin/r-admins/:id     - Delete R-Admin
 * - GET    /admin/logs             - List system logs
 * - GET    /admin/logs/export      - Export system logs
 */
@Module({
    imports: [
        PrismaModule,
        MailModule,
        LoggerModule,
        AuthModule, // ✅ ADDED: Required for AuthGuard and RolesGuard
    ],
    controllers: [
        AdminController,
        RAdminController,
        SystemLogsController,
    ],
    providers: [
        // Services
        AdminService,
        RAdminService,
        SystemLogsService,

        // Repositories
        AdminRepository,
        RAdminRepository,
        SystemLogsRepository,
    ],
    exports: [
        // Export services in case other modules need them
        AdminService,
        RAdminService,
        SystemLogsService,
    ],
})
export class AdminModule { }


===== src/admin/controllers/admin.controller.ts =====
// src/admin/controllers/admin.controller.ts

import {
    Controller,
    Get,
    Put,
    Body,
    UseGuards,
    HttpCode,
    HttpStatus,
    Req,
} from '@nestjs/common';
import type { Request } from 'express';
import type { User } from '@prisma/client'; // ✅ FIXED: Use 'import type'
import { UserRole } from '@prisma/client';
import { AdminService } from '../services/admin.service';
import { AuthGuard } from '@auth/guards/auth.guard';
import { RolesGuard } from '@auth/guards/roles.guard';
import { Roles } from '@auth/decorators/roles.decorator';
import { CurrentUser } from '@auth/decorators/current-user.decorator';
import { ResponseBuilder } from '@common/utils/response-builder.util';
import { UpdateAdminProfileDto } from '../dto/update-admin-profile.dto';

/**
 * Admin Controller
 * Handles Admin (Super Admin) profile and dashboard endpoints
 * 
 * Base path: /admin
 */
@Controller('admin')
@UseGuards(AuthGuard, RolesGuard)
@Roles(UserRole.ADMIN)
export class AdminController {
    constructor(
        private readonly adminService: AdminService,
        private readonly responseBuilder: ResponseBuilder,
    ) { }

    // ============================================
    // PROFILE ENDPOINTS
    // ============================================

    /**
     * Get admin profile
     * GET /admin/profile
     */
    @Get('profile')
    @HttpCode(HttpStatus.OK)
    async getProfile(
        @CurrentUser() user: User,
        @Req() req: Request,
    ) {
        const profile = await this.adminService.getProfile(user.id);

        return this.responseBuilder.success(
            profile,
            undefined,
            req.url,
        );
    }

    /**
     * Update admin profile
     * PUT /admin/profile
     */
    @Put('profile')
    @HttpCode(HttpStatus.OK)
    async updateProfile(
        @CurrentUser() user: User,
        @Body() dto: UpdateAdminProfileDto,
        @Req() req: Request,
    ) {
        const updatedProfile = await this.adminService.updateProfile(user.id, dto);

        return this.responseBuilder.success(
            updatedProfile,
            'Profile updated successfully',
            req.url,
        );
    }

    // ============================================
    // DASHBOARD ENDPOINTS
    // ============================================

    /**
     * Get admin dashboard data
     * GET /admin/dashboard
     */
    @Get('dashboard')
    @HttpCode(HttpStatus.OK)
    async getDashboard(@Req() req: Request) {
        const dashboardData = await this.adminService.getDashboard();

        return this.responseBuilder.success(
            dashboardData,
            undefined,
            req.url,
        );
    }
}


===== src/admin/controllers/radmin.controller.ts =====
// src/admin/controllers/radmin.controller.ts

import {
    Controller,
    Get,
    Post,
    Put,
    Delete,
    Body,
    Param,
    Query,
    UseGuards,
    HttpCode,
    HttpStatus,
    Req,
} from '@nestjs/common';
import type { Request } from 'express';
import type { User } from '@prisma/client'; // ✅ FIXED: Use 'import type'
import { UserRole } from '@prisma/client';
import { RAdminService } from '../services/radmin.service';
import { AuthGuard } from '@auth/guards/auth.guard';
import { RolesGuard } from '@auth/guards/roles.guard';
import { Roles } from '@auth/decorators/roles.decorator';
import { CurrentUser } from '@auth/decorators/current-user.decorator';
import { ResponseBuilder } from '@common/utils/response-builder.util';
import { CreateRAdminDto } from '../dto/create-radmin.dto';
import { UpdateRAdminDto } from '../dto/update-radmin.dto';
import { RAdminQueryDto } from '../dto/radmin-query.dto';
import { sanitizeIpAddress } from '@auth/utils/auth.utils';

/**
 * R-Admin Controller
 * Handles R-Admin CRUD operations
 * 
 * Base path: /admin/r-admins
 */
@Controller('admin/r-admins')
@UseGuards(AuthGuard, RolesGuard)
@Roles(UserRole.ADMIN)
export class RAdminController {
    constructor(
        private readonly radminService: RAdminService,
        private readonly responseBuilder: ResponseBuilder,
    ) { }

    // ============================================
    // R-ADMIN CRUD ENDPOINTS
    // ============================================

    /**
     * Get all R-Admins with pagination and search
     * GET /admin/r-admins
     */
    @Get()
    @HttpCode(HttpStatus.OK)
    async findAll(
        @Query() query: RAdminQueryDto,
        @Req() req: Request,
    ) {
        const result = await this.radminService.findAll(query);

        // ✅ FIXED: Add hasNextPage and hasPreviousPage to pagination metadata
        return this.responseBuilder.paginated(
            result.data,
            {
                ...result.pagination,
                hasNextPage: result.pagination.page < result.pagination.totalPages,
                hasPreviousPage: result.pagination.page > 1,
            },
            undefined,
            req.url,
        );
    }

    /**
     * Get R-Admin statistics
     * GET /admin/r-admins/stats
     */
    @Get('stats')
    @HttpCode(HttpStatus.OK)
    async getStats(@Req() req: Request) {
        const stats = await this.radminService.getStats();

        return this.responseBuilder.success(
            stats,
            undefined,
            req.url,
        );
    }

    /**
     * Get R-Admin by ID
     * GET /admin/r-admins/:id
     */
    @Get(':id')
    @HttpCode(HttpStatus.OK)
    async findOne(
        @Param('id') id: string,
        @Req() req: Request,
    ) {
        const radmin = await this.radminService.findOne(id);

        return this.responseBuilder.success(
            radmin,
            undefined,
            req.url,
        );
    }

    /**
     * Create new R-Admin
     * POST /admin/r-admins
     */
    @Post()
    @HttpCode(HttpStatus.CREATED)
    async create(
        @CurrentUser() user: User,
        @Body() dto: CreateRAdminDto,
        @Req() req: Request,
    ) {
        const ipAddress = sanitizeIpAddress(req.ip);
        const radmin = await this.radminService.create(dto, user.id, ipAddress);

        return this.responseBuilder.success(
            radmin,
            'R-Admin account created successfully. Welcome email sent.',
            req.url,
        );
    }

    /**
     * Update R-Admin
     * PUT /admin/r-admins/:id
     */
    @Put(':id')
    @HttpCode(HttpStatus.OK)
    async update(
        @Param('id') id: string,
        @CurrentUser() user: User,
        @Body() dto: UpdateRAdminDto,
        @Req() req: Request,
    ) {
        const ipAddress = sanitizeIpAddress(req.ip);
        const radmin = await this.radminService.update(id, dto, user.id, ipAddress);

        return this.responseBuilder.success(
            radmin,
            'R-Admin updated successfully',
            req.url,
        );
    }

    /**
     * Delete R-Admin
     * DELETE /admin/r-admins/:id
     */
    @Delete(':id')
    @HttpCode(HttpStatus.OK)
    async delete(
        @Param('id') id: string,
        @CurrentUser() user: User,
        @Req() req: Request,
    ) {
        const ipAddress = sanitizeIpAddress(req.ip);
        const result = await this.radminService.delete(id, user.id, ipAddress);

        return this.responseBuilder.success(
            result,
            'R-Admin deleted successfully',
            req.url,
        );
    }
}


===== src/admin/services/admin.service.ts =====
// src/admin/services/admin.service.ts

import { Injectable, NotFoundException } from '@nestjs/common';
import { AdminRepository } from '../repositories/admin.repository';
import { UpdateAdminProfileDto } from '../dto/update-admin-profile.dto';
import { ErrorCodes } from '@common/enums/error-codes.enum';
import { formatUserResponse } from '@auth/utils/auth.utils';

/**
 * Admin Service
 * Handles business logic for Admin (Super Admin) operations
 */
@Injectable()
export class AdminService {
    constructor(private readonly adminRepository: AdminRepository) { }

    // ============================================
    // PROFILE MANAGEMENT
    // ============================================

    /**
     * Get admin profile
     */
    async getProfile(userId: string) {
        const admin = await this.adminRepository.findAdminById(userId);

        if (!admin) {
            throw new NotFoundException({
                code: ErrorCodes.USER_NOT_FOUND,
                message: 'Admin user not found',
            });
        }

        return formatUserResponse(admin);
    }

    /**
     * Update admin profile
     */
    async updateProfile(userId: string, dto: UpdateAdminProfileDto) {
        // Check if admin exists
        const admin = await this.adminRepository.findAdminById(userId);

        if (!admin) {
            throw new NotFoundException({
                code: ErrorCodes.USER_NOT_FOUND,
                message: 'Admin user not found',
            });
        }

        // Update profile
        const updatedAdmin = await this.adminRepository.updateAdminProfile(userId, {
            firstName: dto.firstName,
            lastName: dto.lastName,
            phone: dto.phone,
        });

        return formatUserResponse(updatedAdmin);
    }

    // ============================================
    // DASHBOARD
    // ============================================

    /**
     * Get admin dashboard data
     */
    async getDashboard() {
        const [totalZoneAdmins, activeProjects, pendingReports, recentActivities] =
            await Promise.all([
                this.adminRepository.getTotalRAdminsCount(),
                this.adminRepository.getActiveProjectsCount(),
                this.adminRepository.getPendingReportsCount(),
                this.adminRepository.getRecentActivities(10),
            ]);

        // Format recent activities
        const formattedActivities = recentActivities.map((log) => ({
            id: log.id,
            user: log.user
                ? `${log.user.firstName} ${log.user.lastName}`
                : 'System',
            userId: log.userId || null,
            action: log.description || log.event,
            time: this.getRelativeTime(log.createdAt),
            timestamp: log.createdAt.toISOString(),
            type: log.eventType,
        }));

        return {
            stats: {
                totalZoneAdmins,
                activeProjects,
                pendingReports,
            },
            recentActivities: formattedActivities,
        };
    }

    // ============================================
    // HELPER METHODS
    // ============================================

    /**
     * Get relative time string (e.g., "2 minutes ago")
     */
    private getRelativeTime(date: Date): string {
        const now = new Date();
        const diffMs = now.getTime() - date.getTime();
        const diffMins = Math.floor(diffMs / (1000 * 60));
        const diffHours = Math.floor(diffMs / (1000 * 60 * 60));
        const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));

        if (diffMins < 1) return 'Just now';
        if (diffMins < 60) return `${diffMins} minute${diffMins > 1 ? 's' : ''} ago`;
        if (diffHours < 24) return `${diffHours} hour${diffHours > 1 ? 's' : ''} ago`;
        return `${diffDays} day${diffDays > 1 ? 's' : ''} ago`;
    }
}


===== src/admin/services/radmin.service.ts =====
// src/admin/services/radmin.service.ts

import {
    Injectable,
    NotFoundException,
    ConflictException,
    BadRequestException,
} from '@nestjs/common';
import { RAdminRepository } from '../repositories/radmin.repository';
import { SystemLogsRepository } from '../repositories/system-logs.repository';
import { MailService } from '@core/mail/mail.service';
import { CreateRAdminDto } from '../dto/create-radmin.dto';
import { UpdateRAdminDto } from '../dto/update-radmin.dto';
import { RAdminQueryDto } from '../dto/radmin-query.dto';
import { AccountStatus, SystemLogType, SystemLogStatus } from '@prisma/client';
import { ErrorCodes } from '@common/enums/error-codes.enum';
import {
    RADMIN_ALLOWED_DOMAIN,
    DEFAULT_RADMIN_STATUS,
    ADMIN_ERROR_MESSAGES,
} from '../constants/admin.constants';
import { getEmailDomain } from '@auth/utils/auth.utils';
import { AppLogger } from '@core/logger/logger.service';

/**
 * R-Admin Service
 * Handles business logic for R-Admin CRUD operations
 */
@Injectable()
export class RAdminService {
    constructor(
        private readonly radminRepository: RAdminRepository,
        private readonly systemLogsRepository: SystemLogsRepository,
        private readonly mailService: MailService,
        private readonly logger: AppLogger,
    ) { }

    // ============================================
    // R-ADMIN CRUD OPERATIONS
    // ============================================

    /**
     * Get all R-Admins with pagination
     */
    async findAll(query: RAdminQueryDto) {
        const { page = 1, limit = 10, search } = query;

        const { radmins, total } = await this.radminRepository.findAllRAdmins({
            page,
            limit,
            search,
        });

        // Format response to match frontend types
        const formattedRAdmins = radmins.map((radmin) => ({
            id: radmin.id,
            firstName: radmin.firstName,
            lastName: radmin.lastName,
            name: `${radmin.firstName} ${radmin.lastName}`,
            email: radmin.email,
            phone: radmin.phone,
            status: radmin.status.toLowerCase() as 'active' | 'inactive',
            projects: radmin._count.managedProjects,
            createdAt: radmin.createdAt.toISOString(),
            updatedAt: radmin.updatedAt.toISOString(),
            createdBy: radmin.createdById,
            lastLogin: radmin.lastLogin?.toISOString(),
        }));

        const totalPages = Math.ceil(total / limit);

        return {
            success: true,
            data: formattedRAdmins,
            pagination: {
                page,
                limit,
                total,
                totalPages,
            },
        };
    }

    /**
     * Get R-Admin by ID
     */
    async findOne(id: string) {
        const radmin = await this.radminRepository.findRAdminById(id);

        if (!radmin) {
            throw new NotFoundException({
                code: ErrorCodes.USER_NOT_FOUND,
                message: ADMIN_ERROR_MESSAGES.RADMIN_NOT_FOUND,
            });
        }

        return {
            id: radmin.id,
            firstName: radmin.firstName,
            lastName: radmin.lastName,
            name: `${radmin.firstName} ${radmin.lastName}`,
            email: radmin.email,
            phone: radmin.phone,
            status: radmin.status.toLowerCase() as 'active' | 'inactive',
            createdAt: radmin.createdAt.toISOString(),
            updatedAt: radmin.updatedAt.toISOString(),
        };
    }

    /**
     * Create new R-Admin
     */
    async create(dto: CreateRAdminDto, adminId: string, ipAddress?: string) {
        // Validate email domain
        const emailDomain = getEmailDomain(dto.email);
        if (emailDomain !== RADMIN_ALLOWED_DOMAIN) {
            throw new BadRequestException({
                code: 'INVALID_EMAIL_DOMAIN',
                message: ADMIN_ERROR_MESSAGES.RADMIN_EMAIL_DOMAIN_INVALID,
            });
        }

        // Check if email already exists
        const existingByEmail = await this.radminRepository.findRAdminByEmail(dto.email);
        if (existingByEmail) {
            throw new ConflictException({
                code: ErrorCodes.EMAIL_ALREADY_EXISTS,
                message: ADMIN_ERROR_MESSAGES.RADMIN_EMAIL_EXISTS,
            });
        }

        // Check if phone already exists
        const existingByPhone = await this.radminRepository.findRAdminByPhone(dto.phone);
        if (existingByPhone) {
            throw new ConflictException({
                code: ErrorCodes.PHONE_ALREADY_EXISTS,
                message: ADMIN_ERROR_MESSAGES.RADMIN_PHONE_EXISTS,
            });
        }

        // Create R-Admin
        const radmin = await this.radminRepository.createRAdmin({
            email: dto.email,
            firstName: dto.firstName,
            lastName: dto.lastName,
            phone: dto.phone,
            companyDomain: RADMIN_ALLOWED_DOMAIN,
            status: dto.status || (DEFAULT_RADMIN_STATUS as AccountStatus),
            createdById: adminId,
        });

        // Log creation
        await this.systemLogsRepository.createLog({
            userId: adminId,
            event: 'R_ADMIN_CREATED',
            eventType: SystemLogType.CREATE,
            description: `Created R-Admin account for ${radmin.firstName} ${radmin.lastName} (${radmin.email})`,
            status: SystemLogStatus.SUCCESS,
            metadata: {
                radminId: radmin.id,
                email: radmin.email,
            },
            ipAddress,
        });

        // Send welcome email (async, don't block)
        this.mailService
            .sendRAdminWelcomeEmail(radmin.email, radmin.firstName, radmin.lastName)
            .catch((err) => {
                this.logger.error(
                    `Failed to send welcome email to ${radmin.email}`,
                    err,
                    'RAdminService',
                );
            });

        this.logger.log(
            `R-Admin created: ${radmin.email} by Admin: ${adminId}`,
            'RAdminService',
        );

        return {
            id: radmin.id,
            firstName: radmin.firstName,
            lastName: radmin.lastName,
            name: `${radmin.firstName} ${radmin.lastName}`,
            email: radmin.email,
            phone: radmin.phone,
            status: radmin.status.toLowerCase() as 'active' | 'inactive',
            createdAt: radmin.createdAt.toISOString(),
        };
    }

    /**
     * Update R-Admin
     */
    async update(
        id: string,
        dto: UpdateRAdminDto,
        adminId: string,
        ipAddress?: string,
    ) {
        // Check if R-Admin exists
        const existing = await this.radminRepository.findRAdminById(id);
        if (!existing) {
            throw new NotFoundException({
                code: ErrorCodes.USER_NOT_FOUND,
                message: ADMIN_ERROR_MESSAGES.RADMIN_NOT_FOUND,
            });
        }

        // Check if phone is being changed and already exists
        if (dto.phone !== existing.phone) {
            const existingByPhone = await this.radminRepository.findRAdminByPhone(dto.phone);
            if (existingByPhone && existingByPhone.id !== id) {
                throw new ConflictException({
                    code: ErrorCodes.PHONE_ALREADY_EXISTS,
                    message: ADMIN_ERROR_MESSAGES.RADMIN_PHONE_EXISTS,
                });
            }
        }

        // Update R-Admin
        const radmin = await this.radminRepository.updateRAdmin(id, {
            firstName: dto.firstName,
            lastName: dto.lastName,
            phone: dto.phone,
            status: dto.status || existing.status,
        });

        // Log update
        await this.systemLogsRepository.createLog({
            userId: adminId,
            event: 'R_ADMIN_UPDATED',
            eventType: SystemLogType.UPDATE,
            description: `Updated R-Admin account for ${radmin.firstName} ${radmin.lastName}`,
            status: SystemLogStatus.SUCCESS,
            metadata: {
                radminId: radmin.id,
                changes: dto,
            },
            ipAddress,
        });

        // Send update notification email (async)
        const updateDetails = this.buildUpdateDetailsText(existing, dto);
        this.mailService
            .sendRAdminUpdateEmail(radmin.email, radmin.firstName, updateDetails)
            .catch((err) => {
                this.logger.error(
                    `Failed to send update email to ${radmin.email}`,
                    err,
                    'RAdminService',
                );
            });

        this.logger.log(`R-Admin updated: ${radmin.email} by Admin: ${adminId}`, 'RAdminService');

        return {
            id: radmin.id,
            firstName: radmin.firstName,
            lastName: radmin.lastName,
            name: `${radmin.firstName} ${radmin.lastName}`,
            email: radmin.email,
            phone: radmin.phone,
            status: radmin.status.toLowerCase() as 'active' | 'inactive',
            updatedAt: radmin.updatedAt.toISOString(),
        };
    }

    /**
     * Delete R-Admin (soft delete)
     */
    async delete(id: string, adminId: string, ipAddress?: string) {
        // Check if R-Admin exists
        const existing = await this.radminRepository.findRAdminById(id);
        if (!existing) {
            throw new NotFoundException({
                code: ErrorCodes.USER_NOT_FOUND,
                message: ADMIN_ERROR_MESSAGES.RADMIN_NOT_FOUND,
            });
        }

        // Soft delete
        await this.radminRepository.deleteRAdmin(id);

        // Log deletion
        await this.systemLogsRepository.createLog({
            userId: adminId,
            event: 'R_ADMIN_DELETED',
            eventType: SystemLogType.DELETE,
            description: `Deleted R-Admin account: ${existing.firstName} ${existing.lastName} (${existing.email})`,
            status: SystemLogStatus.SUCCESS,
            metadata: {
                radminId: id,
                email: existing.email,
            },
            ipAddress,
        });

        this.logger.log(
            `R-Admin deleted: ${existing.email} by Admin: ${adminId}`,
            'RAdminService',
        );

        return {
            message: 'R-Admin deleted successfully',
        };
    }

    /**
     * Get R-Admin statistics
     */
    async getStats() {
        const stats = await this.radminRepository.getRAdminStats();

        return {
            total: stats.total,
            active: stats.active,
            inactive: stats.inactive,
            totalProjects: stats.totalProjects,
        };
    }

    // ============================================
    // HELPER METHODS
    // ============================================

    /**
     * Build update details text for email
     */
    private buildUpdateDetailsText(existing: any, dto: UpdateRAdminDto): string {
        const changes: string[] = [];

        if (dto.firstName !== existing.firstName || dto.lastName !== existing.lastName) {
            changes.push(
                `Name changed from "${existing.firstName} ${existing.lastName}" to "${dto.firstName} ${dto.lastName}"`,
            );
        }

        if (dto.phone !== existing.phone) {
            changes.push(`Phone changed from "${existing.phone}" to "${dto.phone}"`);
        }

        if (dto.status && dto.status !== existing.status) {
            changes.push(
                `Status changed from "${existing.status}" to "${dto.status}"`,
            );
        }

        return changes.join('<br>');
    }
}


===== src/admin/repositories/admin.repository.ts =====
// src/admin/repositories/admin.repository.ts

import { Injectable } from '@nestjs/common';
import { PrismaService } from '@core/database/prisma.service';
import { User, UserRole } from '@prisma/client';

/**
 * Admin Repository
 * Handles all database queries for Admin (Super Admin) operations
 */
@Injectable()
export class AdminRepository {
    constructor(private readonly prisma: PrismaService) { }

    // ============================================
    // ADMIN PROFILE QUERIES
    // ============================================

    /**
     * Get admin user by ID with full profile
     */
    async findAdminById(userId: string): Promise<User | null> {
        return this.prisma.user.findFirst({
            where: {
                id: userId,
                role: UserRole.ADMIN,
            },
        });
    }

    /**
     * Update admin profile
     */
    async updateAdminProfile(
        userId: string,
        data: {
            firstName: string;
            lastName: string;
            phone: string;
        },
    ): Promise<User> {
        return this.prisma.user.update({
            where: { id: userId },
            data: {
                firstName: data.firstName,
                lastName: data.lastName,
                phone: data.phone,
                updatedAt: new Date(),
            },
        });
    }

    // ============================================
    // DASHBOARD QUERIES
    // ============================================

    /**
     * Get total count of R-Admins
     */
    async getTotalRAdminsCount(): Promise<number> {
        return this.prisma.user.count({
            where: {
                role: UserRole.R_ADMIN,
                deletedAt: null,
            },
        });
    }

    /**
     * Get total active projects count
     */
    async getActiveProjectsCount(): Promise<number> {
        return this.prisma.project.count({
            where: {
                status: {
                    in: ['NOT_STARTED', 'IN_PROGRESS', 'TESTING_COMPLETE'],
                },
                deletedAt: null,
            },
        });
    }

    /**
     * Get pending reports count
     */
    async getPendingReportsCount(): Promise<number> {
        return this.prisma.report.count({
            where: {
                status: {
                    in: ['PENDING', 'UNDER_REVIEW'],
                },
            },
        });
    }

    /**
     * Get recent activities (from AuthAuditLog)
     */
    async getRecentActivities(limit: number = 10) {
        return this.prisma.authAuditLog.findMany({
            take: limit,
            orderBy: {
                createdAt: 'desc',
            },
            include: {
                user: {
                    select: {
                        id: true,
                        firstName: true,
                        lastName: true,
                        email: true,
                        role: true,
                    },
                },
            },
        });
    }
}


===== src/admin/repositories/radmin.repository.ts =====
// src/admin/repositories/radmin.repository.ts

import { Injectable } from '@nestjs/common';
import { PrismaService } from '@core/database/prisma.service';
import { User, UserRole, AccountStatus } from '@prisma/client';

/**
 * R-Admin Repository
 * Handles all database queries for R-Admin management
 */
@Injectable()
export class RAdminRepository {
    constructor(private readonly prisma: PrismaService) { }

    // ============================================
    // R-ADMIN QUERIES
    // ============================================

    /**
     * Find all R-Admins with pagination and search
     */
    async findAllRAdmins(params: {
        page: number;
        limit: number;
        search?: string;
    }) {
        const { page, limit, search } = params;
        const skip = (page - 1) * limit;

        const where: any = {
            role: UserRole.R_ADMIN,
            deletedAt: null,
        };

        // Apply search filter
        if (search) {
            where.OR = [
                { firstName: { contains: search, mode: 'insensitive' } },
                { lastName: { contains: search, mode: 'insensitive' } },
                { email: { contains: search, mode: 'insensitive' } },
            ];
        }

        const [radmins, total] = await Promise.all([
            this.prisma.user.findMany({
                where,
                skip,
                take: limit,
                orderBy: {
                    createdAt: 'desc',
                },
                select: {
                    id: true,
                    firstName: true,
                    lastName: true,
                    email: true,
                    phone: true,
                    status: true,
                    createdAt: true,
                    updatedAt: true,
                    lastLogin: true,
                    createdById: true,
                    // Count projects managed by this R-Admin
                    _count: {
                        select: {
                            managedProjects: true,
                        },
                    },
                },
            }),
            this.prisma.user.count({ where }),
        ]);

        return { radmins, total };
    }

    /**
     * Find R-Admin by ID
     */
    async findRAdminById(id: string): Promise<User | null> {
        return this.prisma.user.findFirst({
            where: {
                id,
                role: UserRole.R_ADMIN,
                deletedAt: null,
            },
        });
    }

    /**
     * Find R-Admin by email
     */
    async findRAdminByEmail(email: string): Promise<User | null> {
        return this.prisma.user.findFirst({
            where: {
                email,
                role: UserRole.R_ADMIN,
                deletedAt: null,
            },
        });
    }

    /**
     * Find R-Admin by phone
     */
    async findRAdminByPhone(phone: string): Promise<User | null> {
        return this.prisma.user.findFirst({
            where: {
                phone,
                role: UserRole.R_ADMIN,
                deletedAt: null,
            },
        });
    }

    /**
     * Create new R-Admin
     */
    async createRAdmin(data: {
        email: string;
        firstName: string;
        lastName: string;
        phone: string;
        companyDomain: string;
        status: AccountStatus;
        createdById: string;
    }): Promise<User> {
        return this.prisma.user.create({
            data: {
                email: data.email,
                firstName: data.firstName,
                lastName: data.lastName,
                phone: data.phone,
                role: UserRole.R_ADMIN,
                companyEmail: data.email, // Same as personal email for R-Admin
                companyDomain: data.companyDomain,
                status: data.status,
                isEmailVerified: true, // Auto-verified for R-Admin
                emailVerifiedAt: new Date(),
                createdById: data.createdById,
            },
        });
    }

    /**
     * Update R-Admin
     */
    async updateRAdmin(
        id: string,
        data: {
            firstName: string;
            lastName: string;
            phone: string;
            status: AccountStatus;
        },
    ): Promise<User> {
        return this.prisma.user.update({
            where: { id },
            data: {
                firstName: data.firstName,
                lastName: data.lastName,
                phone: data.phone,
                status: data.status,
                updatedAt: new Date(),
            },
        });
    }

    /**
     * Delete R-Admin (soft delete)
     */
    async deleteRAdmin(id: string): Promise<User> {
        return this.prisma.user.update({
            where: { id },
            data: {
                deletedAt: new Date(),
                status: AccountStatus.DELETED,
            },
        });
    }

    // ============================================
    // STATISTICS QUERIES
    // ============================================

    /**
     * Get R-Admin statistics
     */
    async getRAdminStats() {
        const [total, active, inactive, totalProjectsData] = await Promise.all([
            this.prisma.user.count({
                where: {
                    role: UserRole.R_ADMIN,
                    deletedAt: null,
                },
            }),
            this.prisma.user.count({
                where: {
                    role: UserRole.R_ADMIN,
                    status: AccountStatus.ACTIVE,
                    deletedAt: null,
                },
            }),
            this.prisma.user.count({
                where: {
                    role: UserRole.R_ADMIN,
                    status: AccountStatus.INACTIVE,
                    deletedAt: null,
                },
            }),
            this.prisma.project.count({
                where: {
                    radmin: {
                        role: UserRole.R_ADMIN,
                        deletedAt: null,
                    },
                    deletedAt: null,
                },
            }),
        ]);

        return {
            total,
            active,
            inactive,
            totalProjects: totalProjectsData,
        };
    }
}


===== src/admin/dto/create-radmin.dto.ts =====
// src/admin/dto/create-radmin.dto.ts

import {
    IsString,
    IsNotEmpty,
    IsEmail,
    MinLength,
    MaxLength,
    Matches,
    IsEnum,
    IsOptional,
} from 'class-validator';
import { AccountStatus } from '@prisma/client';
import { PHONE_REGEX, ADMIN_ERROR_MESSAGES } from '../constants/admin.constants';

/**
 * DTO for creating R-Admin account
 */
export class CreateRAdminDto {
    @IsString({ message: 'First name must be a string' })
    @IsNotEmpty({ message: 'First name is required' })
    @MinLength(2, { message: 'First name must be at least 2 characters' })
    @MaxLength(50, { message: 'First name must not exceed 50 characters' })
    firstName: string;

    @IsString({ message: 'Last name must be a string' })
    @IsNotEmpty({ message: 'Last name is required' })
    @MinLength(2, { message: 'Last name must be at least 2 characters' })
    @MaxLength(50, { message: 'Last name must not exceed 50 characters' })
    lastName: string;

    @IsEmail({}, { message: 'Invalid email format' })
    @IsNotEmpty({ message: 'Email is required' })
    @MaxLength(255, { message: 'Email must not exceed 255 characters' })
    email: string; // Will be validated for @rivedix.com domain in service

    @IsString({ message: 'Phone number must be a string' })
    @IsNotEmpty({ message: 'Phone number is required' })
    @Matches(PHONE_REGEX, { message: ADMIN_ERROR_MESSAGES.INVALID_PHONE_FORMAT })
    phone: string; // Expected format: +919876543210

    @IsEnum(AccountStatus, { message: 'Invalid account status' })
    @IsOptional()
    status?: AccountStatus; // Default: ACTIVE
}


===== src/admin/dto/update-radmin.dto.ts =====

// src/admin/dto/update-radmin.dto.ts

import {
    IsString,
    IsNotEmpty,
    MinLength,
    MaxLength,
    Matches,
    IsEnum,
    IsOptional,
} from 'class-validator';
import { AccountStatus } from '@prisma/client';
import { PHONE_REGEX, ADMIN_ERROR_MESSAGES } from '../constants/admin.constants';

/**
 * DTO for updating R-Admin account
 * Cannot update email (security)
 */
export class UpdateRAdminDto {
    @IsString({ message: 'First name must be a string' })
    @IsNotEmpty({ message: 'First name is required' })
    @MinLength(2, { message: 'First name must be at least 2 characters' })
    @MaxLength(50, { message: 'First name must not exceed 50 characters' })
    firstName: string;

    @IsString({ message: 'Last name must be a string' })
    @IsNotEmpty({ message: 'Last name is required' })
    @MinLength(2, { message: 'Last name must be at least 2 characters' })
    @MaxLength(50, { message: 'Last name must not exceed 50 characters' })
    lastName: string;

    @IsString({ message: 'Phone number must be a string' })
    @IsNotEmpty({ message: 'Phone number is required' })
    @Matches(PHONE_REGEX, { message: ADMIN_ERROR_MESSAGES.INVALID_PHONE_FORMAT })
    phone: string; // Expected format: +919876543210

    @IsEnum(AccountStatus, { message: 'Invalid account status' })
    @IsOptional()
    status?: AccountStatus;
}


===== prisma/schema.prisma =====
// ==========================================================================================
// PENTRACK - COMPLETE PRODUCTION-READY PRISMA SCHEMA
// ==========================================================================================
// This schema follows industry best practices:
// - Proper normalization (no JSON for relational data)
// - Enums for controlled values
// - Audit trails for compliance
// - Performance indexes
// - Cascade deletes
// - Soft deletes where needed
// ==========================================================================================

// ==========================
// Generator & Datasource
// ==========================
generator client {
    provider = "prisma-client-js"
}

datasource db {
    provider = "postgresql"
    url      = env("DATABASE_URL")
}

// ==========================================================================================
// ENUMS
// ==========================================================================================

// --------------------------------------------------
// USER & AUTH ENUMS
// --------------------------------------------------

enum UserRole {
    ADMIN // super_admin in frontend (Super Admin)
    R_ADMIN // r-admin in frontend (R Admin + Pentester capabilities)
    PENTESTER // pentester in frontend (Penetration Tester)
    CLIENT // client in frontend (Client organization)
    PARTNER // partner in frontend (Partner organization)
}

enum AccountStatus {
    ACTIVE // 'active' in frontend - Account is active
    INACTIVE // 'inactive' in frontend - Account is inactive
    PENDING // Account created but not verified/activated
    SUSPENDED // Temporarily disabled by admin
    DELETED // Soft deleted
}

enum OTPType {
    LOGIN // For login authentication
    SIGNUP // For email verification during signup
    PASSWORD_RESET // For password reset (future)
}

enum OAuthProviderType {
    GOOGLE
    MICROSOFT // Future support
    GITHUB // Future support
}

// --------------------------------------------------
// PROJECT ENUMS
// --------------------------------------------------

enum ProjectStatus {
    NOT_STARTED // 'not_started' in frontend
    IN_PROGRESS // 'in_progress' in frontend
    TESTING_COMPLETE // 'testing_complete' in frontend
    REPORT_SUBMITTED // 'report_submitted' in frontend
    UNDER_REVIEW // 'Under Review' in frontend
    REWORK_NEEDED // 'rework_needed' in frontend
    COMPLETED // 'completed' in frontend
    REJECTED // 'rejected' in frontend
    OVERDUE // 'overdue' in frontend
}

enum ProjectPriority {
    LOW // 'low' in frontend
    MEDIUM // 'medium' in frontend
    HIGH // 'high' in frontend
    CRITICAL // 'critical' in frontend
}

enum ProjectActivityType {
    CREATED // Project created
    STATUS_CHANGED // Status updated
    PENTESTER_ASSIGNED // Pentester assigned to project
    PENTESTER_CHANGED // Pentester reassigned
    DEADLINE_CHANGED // Deadline modified
    SCOPE_UPDATED // Scope of work updated
    PRIORITY_CHANGED // Priority changed
    REPORT_SUBMITTED // Report submitted for review
    REPORT_APPROVED // Report approved
    REPORT_REJECTED // Report rejected
    COMMENT_ADDED // Comment added to project
    TIMELINE_UPDATED // Timeline updated
}

// --------------------------------------------------
// REPORT ENUMS
// --------------------------------------------------

enum ReportStatus {
    PENDING // Initial submission, waiting for review
    UNDER_REVIEW // Being reviewed by R-Admin
    APPROVED // Approved and published
    REJECTED // Rejected, needs rework
    RESUBMITTED // Resubmitted after rejection
}

// --------------------------------------------------
// NOTIFICATION ENUMS
// --------------------------------------------------

enum NotificationType {
    REPORT // Report-related notifications
    STATUS // Status change notifications
    PROJECT // Project-related notifications
    DEADLINE // Deadline reminders
    OVERDUE // Overdue alerts
    USER // User-related notifications
    SYSTEM // System notifications
}

enum NotificationCategory {
    PROJECT_UPDATES // Project updates and changes
    REPORT_UPDATES // Report submissions and reviews
    DEADLINE_REMINDERS // Upcoming deadlines
    STATUS_CHANGES // Status changes
    USER_ACTIONS // User actions (assignments, etc.)
    SYSTEM_ALERTS // System-level alerts
}

enum NotificationPriority {
    LOW
    NORMAL
    HIGH
    CRITICAL
}

// --------------------------------------------------
// SYSTEM LOG ENUMS
// --------------------------------------------------

enum SystemLogType {
    CREATE // Entity creation
    UPDATE // Entity update
    DELETE // Entity deletion
    AUTH // Authentication events
    REPORT // Report events
    EXPORT // Data export events
    BACKUP // Backup events
}

enum SystemLogStatus {
    SUCCESS
    FAILED
}

// ==========================================================================================
// USER & AUTH MODELS
// ==========================================================================================

// --------------------------------------------------
// USER MODEL (Base for all roles)
// --------------------------------------------------

model User {
    id    String @id @default(uuid())
    email String @unique

    // Password field (NOT USED - all auth is OTP or OAuth)
    password String? // Always NULL for this system

    // Basic Info
    firstName String
    lastName  String
    phone     String @unique // Format: +91XXXXXXXXXX

    // Role & Status
    role   UserRole
    status AccountStatus @default(PENDING)

    // Company Info (Only for R_ADMIN and PENTESTER)
    companyEmail  String? // e.g., rana@rivedix.com
    companyDomain String? // e.g., rivedix.com

    // Profile Image
    profileImage String? // S3 URL or local path

    // Email Verification
    isEmailVerified Boolean   @default(false)
    emailVerifiedAt DateTime?

    // Login Tracking
    lastLogin   DateTime?
    lastLoginIp String?

    // Timestamps
    createdAt DateTime  @default(now())
    updatedAt DateTime  @updatedAt
    deletedAt DateTime? // Soft delete

    // ============================================
    // RELATIONS
    // ============================================

    // Auth relations
    sessions       Session[]
    otpCodes       OTPCode[]
    oauthProviders OAuthProvider[]
    auditLogs      AuthAuditLog[]

    // Role-specific profile relations
    clientProfile    Client?
    partnerProfile   Partner?
    pentesterProfile Pentester?

    // Hierarchy relations (who created whom)
    createdRAdmins    User[]    @relation("AdminCreatedRAdmins")
    createdBy         User?     @relation("AdminCreatedRAdmins", fields: [createdById], references: [id])
    createdById       String?
    createdPentesters User[]    @relation("RAdminCreatedPentesters")
    createdByRAdmin   User?     @relation("RAdminCreatedPentesters", fields: [createdByRAdminId], references: [id])
    createdByRAdminId String?
    createdClients    Client[]  @relation("RAdminCreatedClients")
    createdPartners   Partner[] @relation("RAdminCreatedPartners")

    // Resource creation relations
    createdServiceCategories ServiceCategory[] @relation("RAdminCreatedServiceCategories")
    createdSubServices       SubService[]      @relation("RAdminCreatedSubServices")
    createdSecurityChecks    SecurityCheck[]   @relation("RAdminCreatedSecurityChecks")

    // Project relations
    managedProjects   Project[]         @relation("RAdminManagedProjects") // Projects managed by R-Admin
    assignedProjects  Project[]         @relation("PentesterAssignedProjects") // Projects assigned to Pentester
    projectActivities ProjectActivity[] @relation("UserProjectActivities") // Project activities by this user

    // Report relations
    submittedReports Report[] @relation("PentesterSubmittedReports")
    reviewedReports  Report[] @relation("RAdminReviewedReports")

    // Notification relations
    notifications Notification[] @relation("UserNotifications")

    @@index([email])
    @@index([role])
    @@index([status])
    @@index([companyDomain])
    @@index([phone])
    @@index([createdById])
    @@index([createdByRAdminId])
    @@map("users")
}

// --------------------------------------------------
// SESSION MODEL
// --------------------------------------------------

model Session {
    id         String   @id @default(uuid())
    userId     String
    token      String   @unique // Random secure token (stored in HTTP-only cookie)
    expiresAt  DateTime
    rememberMe Boolean  @default(false)

    // Security Tracking
    userAgent    String?  @db.Text
    ipAddress    String?
    lastActivity DateTime @default(now())

    // Device Info (for "Active Sessions" feature)
    deviceName String? // e.g., "Chrome on Windows"
    deviceType String? // e.g., "desktop", "mobile"

    // Timestamps
    createdAt DateTime @default(now())

    // Relations
    user User @relation(fields: [userId], references: [id], onDelete: Cascade)

    @@index([token])
    @@index([userId])
    @@index([expiresAt])
    @@index([userId, expiresAt])
    @@map("sessions")
}

// --------------------------------------------------
// OTP MODEL
// --------------------------------------------------

model OTPCode {
    id     String  @id @default(uuid())
    userId String? // NULL if user doesn't exist yet (signup flow)
    email  String // Email where OTP is sent
    code   String // 6-digit code (MUST be hashed before storing!)
    type   OTPType

    // Expiry & Usage
    expiresAt DateTime // Typically 10 minutes from creation
    usedAt    DateTime? // Mark as used instead of deleting (audit trail)

    // Rate Limiting Tracking
    attempts Int @default(0) // Track failed verification attempts

    // Timestamps
    createdAt DateTime @default(now())

    // Relations
    user User? @relation(fields: [userId], references: [id], onDelete: Cascade)

    @@index([email])
    @@index([email, type])
    @@index([code])
    @@index([expiresAt])
    @@index([userId])
    @@map("otp_codes")
}

// --------------------------------------------------
// OAUTH PROVIDER MODEL
// --------------------------------------------------

model OAuthProvider {
    id         String            @id @default(uuid())
    userId     String
    provider   OAuthProviderType
    providerId String // Unique ID from provider (Google's "sub" claim)

    // Profile Data from Provider
    email   String? // Email from OAuth provider
    name    String? // Full name from OAuth provider
    picture String? // Profile picture URL from OAuth provider

    // Token Storage (optional - for API calls to Google on behalf of user)
    accessToken  String?   @db.Text
    refreshToken String?   @db.Text
    expiresAt    DateTime?

    // Tracking
    linkedAt   DateTime @default(now())
    lastUsedAt DateTime @default(now())

    // Timestamps
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    // Relations
    user User @relation(fields: [userId], references: [id], onDelete: Cascade)

    @@unique([userId, provider])
    @@unique([provider, providerId])
    @@index([userId])
    @@index([provider, providerId])
    @@map("oauth_providers")
}

// ==========================================================================================
// PROFILE MODELS
// ==========================================================================================

// --------------------------------------------------
// CLIENT PROFILE MODEL
// --------------------------------------------------

model Client {
    id     String @id @default(uuid())
    userId String @unique

    // Client ID (e.g., "CLI-001")
    clientId String @unique

    // Company Details
    companyName String
    industry    String
    address     String
    website     String?

    // SPOC (Single Point of Contact)
    pointOfContact      String
    pointOfContactEmail String
    pointOfContactPhone String

    // Partner Association
    hasPartner Boolean @default(false)
    partnerId  String?

    // User Type
    userType String @default("client") // 'client' or 'partner'

    // Stats (updated by triggers/application logic)
    totalProjects  Int @default(0)
    activeProjects Int @default(0)

    // Dates
    joinedDate DateTime @default(now())

    // Timestamps
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    // Created By (R-Admin who created this client)
    createdById String?
    createdBy   User?   @relation("RAdminCreatedClients", fields: [createdById], references: [id])

    // Relations
    user     User      @relation(fields: [userId], references: [id], onDelete: Cascade)
    partner  Partner?  @relation("PartnerClients", fields: [partnerId], references: [id])
    projects Project[] @relation("ClientProjects")

    @@index([userId])
    @@index([companyName])
    @@index([clientId])
    @@index([partnerId])
    @@index([createdById])
    @@map("clients")
}

// --------------------------------------------------
// PARTNER PROFILE MODEL
// --------------------------------------------------

model Partner {
    id     String @id @default(uuid())
    userId String @unique

    // Company Details
    companyName String
    industry    String
    address     String
    website     String?

    // SPOC
    pointOfContact      String
    pointOfContactEmail String
    pointOfContactPhone String

    // User Type
    userType String @default("partner")

    // Stats
    totalProjects  Int @default(0)
    activeProjects Int @default(0)

    // Timestamps
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    // Created By (R-Admin who created this partner)
    createdById String?
    createdBy   User?   @relation("RAdminCreatedPartners", fields: [createdById], references: [id])

    // Relations
    user     User      @relation(fields: [userId], references: [id], onDelete: Cascade)
    clients  Client[]  @relation("PartnerClients")
    projects Project[]

    @@index([userId])
    @@index([companyName])
    @@index([createdById])
    @@map("partners")
}

// --------------------------------------------------
// PENTESTER PROFILE MODEL
// --------------------------------------------------

model Pentester {
    id     String @id @default(uuid())
    userId String @unique

    // Profile Info
    specialization String
    location       String
    bio            String?  @db.Text
    memberSince    DateTime @default(now())

    // Stats (updated by triggers/application logic)
    totalProjects      Int @default(0)
    completedProjects  Int @default(0)
    inProgressProjects Int @default(0)

    // Timestamps
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    // Relations
    user User @relation(fields: [userId], references: [id], onDelete: Cascade)

    @@index([userId])
    @@index([specialization])
    @@map("pentesters")
}

// ==========================================================================================
// SERVICE & CHECK MODELS
// ==========================================================================================

// --------------------------------------------------
// SERVICE CATEGORY MODEL
// --------------------------------------------------

model ServiceCategory {
    id String @id @default(uuid())

    // Basic Info
    name        String  @unique
    description String? @db.Text

    // Created By (R-Admin)
    createdById String
    createdBy   User   @relation("RAdminCreatedServiceCategories", fields: [createdById], references: [id])

    // Status
    isActive Boolean @default(true)

    // Stats (computed or updated by triggers)
    projectCount Int @default(0)

    // Timestamps
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    // Relations
    subServices SubService[]
    projects    Project[]

    @@index([createdById])
    @@index([name])
    @@index([isActive])
    @@map("service_categories")
}

// --------------------------------------------------
// SUB SERVICE MODEL (Normalized - not JSON)
// --------------------------------------------------

model SubService {
    id String @id @default(uuid())

    // Service Category
    serviceCategoryId String
    serviceCategory   ServiceCategory @relation(fields: [serviceCategoryId], references: [id], onDelete: Cascade)

    // Basic Info
    name        String
    description String? @db.Text

    // Status
    isActive Boolean @default(true)

    // Created By (R-Admin)
    createdById String
    createdBy   User   @relation("RAdminCreatedSubServices", fields: [createdById], references: [id])

    // Timestamps
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    @@unique([serviceCategoryId, name]) // Unique within a category
    @@index([serviceCategoryId])
    @@index([createdById])
    @@index([isActive])
    @@map("sub_services")
}

// --------------------------------------------------
// SECURITY CHECK MODEL (Check Templates)
// --------------------------------------------------

model SecurityCheck {
    id String @id @default(uuid())

    // Check Details
    title       String
    description String? @db.Text

    // Service Association
    serviceCategory String
    subService      String

    // Mandatory Flag
    isMandatory Boolean @default(false)

    // Created By (R-Admin)
    createdById String
    createdBy   User   @relation("RAdminCreatedSecurityChecks", fields: [createdById], references: [id])

    // Status
    isActive Boolean @default(true)

    // Timestamps
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    // Relations
    reportChecks ReportCheck[]

    @@index([createdById])
    @@index([serviceCategory])
    @@index([subService])
    @@index([isMandatory])
    @@index([isActive])
    @@map("security_checks")
}

// ==========================================================================================
// PROJECT MODELS
// ==========================================================================================

// --------------------------------------------------
// PROJECT MODEL
// --------------------------------------------------

model Project {
    id String @id @default(uuid())

    // Basic Info
    name        String
    description String? @db.Text

    // Client & Partner
    clientId  String
    client    Client   @relation("ClientProjects", fields: [clientId], references: [id])
    partnerId String? // Optional - if referred by partner
    partner   Partner? @relation(fields: [partnerId], references: [id])

    // Management & Assignment
    radminId    String // R-Admin who manages/created this project
    radmin      User    @relation("RAdminManagedProjects", fields: [radminId], references: [id])
    pentesterId String? // Pentester assigned (can be R-Admin if they're doing the work)
    pentester   User?   @relation("PentesterAssignedProjects", fields: [pentesterId], references: [id])
    assignedBy  String? // Who assigned the pentester

    // Service
    serviceCategoryId String?
    serviceCategory   ServiceCategory? @relation(fields: [serviceCategoryId], references: [id])
    services          String[] // Array of service names (e.g., ["VAPT", "Web Application Testing"])

    // Status & Priority
    status   ProjectStatus   @default(NOT_STARTED)
    priority ProjectPriority @default(MEDIUM)

    // Dates
    startDate DateTime?
    endDate   DateTime?
    deadline  DateTime?

    // Progress
    progress Int @default(0) // 0-100

    // Scope Details
    scopeOfWork String? @db.Text
    objectives  String? @db.Text
    targetUrls  String? @db.Text

    // Metadata
    createdBy String? // Who created the project (usually R-Admin)

    // Timestamps
    createdAt DateTime  @default(now())
    updatedAt DateTime  @updatedAt
    deletedAt DateTime? // Soft delete

    // Relations
    reports       Report[]
    timelines     ProjectTimeline[]
    activities    ProjectActivity[]
    notifications Notification[]

    @@index([clientId])
    @@index([partnerId])
    @@index([radminId])
    @@index([pentesterId])
    @@index([status])
    @@index([priority])
    @@index([serviceCategoryId])
    @@index([startDate])
    @@index([endDate])
    @@index([deadline])
    @@map("projects")
}

// --------------------------------------------------
// PROJECT TIMELINE MODEL
// --------------------------------------------------

model ProjectTimeline {
    id String @id @default(uuid())

    // Project relation
    projectId String
    project   Project @relation(fields: [projectId], references: [id], onDelete: Cascade)

    // Timeline stage
    status      ProjectStatus // Use ProjectStatus enum for consistency
    date        DateTime? // When this status was reached (null if not yet reached)
    completed   Boolean       @default(false)
    description String? // Description of this stage

    // Order
    order Int @default(0) // Display order (0, 1, 2, ...)

    // Timestamps
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    @@index([projectId])
    @@index([projectId, order])
    @@index([status])
    @@map("project_timelines")
}

// --------------------------------------------------
// PROJECT ACTIVITY MODEL (Audit Trail)
// --------------------------------------------------

model ProjectActivity {
    id String @id @default(uuid())

    // Project relation
    projectId String
    project   Project @relation(fields: [projectId], references: [id], onDelete: Cascade)

    // User who performed the action
    userId String
    user   User   @relation("UserProjectActivities", fields: [userId], references: [id])

    // Activity details
    activityType ProjectActivityType
    description  String              @db.Text

    // Metadata (store additional context as JSON)
    metadata Json? // e.g., {oldStatus: "IN_PROGRESS", newStatus: "COMPLETED"}

    // Timestamps
    createdAt DateTime @default(now())

    @@index([projectId])
    @@index([userId])
    @@index([activityType])
    @@index([createdAt])
    @@index([projectId, createdAt]) // Composite index for timeline queries
    @@map("project_activities")
}

// ==========================================================================================
// REPORT MODELS
// ==========================================================================================

// --------------------------------------------------
// REPORT MODEL
// --------------------------------------------------

model Report {
    id String @id @default(uuid())

    // Project & User Relations
    projectId   String
    project     Project @relation(fields: [projectId], references: [id])
    pentesterId String // Who submitted
    pentester   User    @relation("PentesterSubmittedReports", fields: [pentesterId], references: [id])
    reviewerId  String? // R-Admin who reviews
    reviewer    User?   @relation("RAdminReviewedReports", fields: [reviewerId], references: [id])

    // Version Tracking
    version Int @default(1)

    // File Info
    fileName String
    fileUrl  String
    fileSize Int // in bytes
    fileType String // e.g., "application/pdf"

    // Status
    status ReportStatus @default(PENDING)

    // Submission Details
    submissionNotes String? @db.Text

    // Review Details
    reviewedAt      DateTime?
    reviewNotes     String?   @db.Text // Approval notes
    rejectionReason String?   @db.Text

    // Timestamps
    submittedAt DateTime @default(now())
    createdAt   DateTime @default(now())
    updatedAt   DateTime @updatedAt

    // Relations
    history ReportHistory[]
    checks  ReportCheck[]

    @@index([projectId])
    @@index([pentesterId])
    @@index([reviewerId])
    @@index([status])
    @@index([version])
    @@index([submittedAt])
    @@map("reports")
}

// --------------------------------------------------
// REPORT HISTORY MODEL
// --------------------------------------------------

model ReportHistory {
    id String @id @default(uuid())

    // Report relation
    reportId String
    report   Report @relation(fields: [reportId], references: [id], onDelete: Cascade)

    // Version info
    version Int
    status  ReportStatus

    // Dates
    submittedDate DateTime
    reviewedDate  DateTime?

    // File info
    fileName String
    fileUrl  String

    // Review details
    approvalNotes   String? @db.Text
    rejectionReason String? @db.Text

    // Timestamps
    createdAt DateTime @default(now())

    @@index([reportId])
    @@index([reportId, version])
    @@index([status])
    @@map("report_histories")
}

// --------------------------------------------------
// REPORT CHECK MODEL (Normalized - not JSON)
// --------------------------------------------------

model ReportCheck {
    id String @id @default(uuid())

    // Report relation
    reportId String
    report   Report @relation(fields: [reportId], references: [id], onDelete: Cascade)

    // Security check template relation
    securityCheckId String
    securityCheck   SecurityCheck @relation(fields: [securityCheckId], references: [id])

    // Completion status
    completed Boolean @default(false)
    notes     String? @db.Text

    // Timestamps
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    @@unique([reportId, securityCheckId]) // Can't have duplicate checks per report
    @@index([reportId])
    @@index([securityCheckId])
    @@index([completed])
    @@map("report_checks")
}

// ==========================================================================================
// NOTIFICATION MODEL
// ==========================================================================================

model Notification {
    id String @id @default(uuid())

    // Recipient
    userId String
    user   User   @relation("UserNotifications", fields: [userId], references: [id], onDelete: Cascade)

    // Notification Details
    type     NotificationType
    category NotificationCategory
    priority NotificationPriority @default(NORMAL)
    title    String
    message  String               @db.Text
    link     String? // Optional link to relevant page

    // Read Status
    read   Boolean   @default(false)
    readAt DateTime?

    // Related Entities
    projectId String?
    project   Project? @relation(fields: [projectId], references: [id])

    // Timestamps
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    @@index([userId])
    @@index([userId, read])
    @@index([type])
    @@index([category])
    @@index([priority])
    @@index([createdAt])
    @@index([projectId])
    @@map("notifications")
}

// ==========================================================================================
// SYSTEM & AUDIT MODELS
// ==========================================================================================

// --------------------------------------------------
// AUTH AUDIT LOG MODEL (System Logs)
// --------------------------------------------------

model AuthAuditLog {
    id     String  @id @default(uuid())
    userId String?

    // Event Info
    event       String // "LOGIN_SUCCESS", "LOGIN_FAILED", "OTP_SENT", etc.
    eventType   SystemLogType // Enum type for filtering
    description String?       @db.Text

    // Status
    status SystemLogStatus @default(SUCCESS)

    // Metadata
    metadata Json? // Additional data

    // Tracking
    ipAddress String?
    userAgent String? @db.Text

    // Timestamps
    createdAt DateTime @default(now())

    // Relations
    user User? @relation(fields: [userId], references: [id])

    @@index([userId])
    @@index([event])
    @@index([eventType])
    @@index([status])
    @@index([createdAt])
    @@index([eventType, status]) // Composite index for filtered queries
    @@map("auth_audit_logs")
}

// --------------------------------------------------
// ACCOUNT INVITATION MODEL
// --------------------------------------------------

model AccountInvitation {
    id        String   @id @default(uuid())
    email     String
    role      UserRole
    invitedBy String // User ID of who sent the invite

    token     String   @unique // Unique token for invitation link
    expiresAt DateTime

    // Status
    status     String    @default("PENDING") // PENDING, ACCEPTED, EXPIRED
    acceptedAt DateTime?

    // Metadata
    metadata Json? // Store additional data (e.g., company info for pentester)

    // Timestamps
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    @@index([email])
    @@index([token])
    @@index([status])
    @@index([expiresAt])
    @@index([role])
    @@map("account_invitations")
}

// ==========================================================================================
// END OF SCHEMA
// ==========================================================================================
// 
// TOTAL MODELS: 21
// - User & Auth: User, Session, OTPCode, OAuthProvider (4)
// - Profiles: Client, Partner, Pentester (3)
// - Services: ServiceCategory, SubService, SecurityCheck (3)
// - Projects: Project, ProjectTimeline, ProjectActivity (3)
// - Reports: Report, ReportHistory, ReportCheck (3)
// - Notifications: Notification (1)
// - System: AuthAuditLog, AccountInvitation (2)
// - Partner Relations: PartnerClients (implicit join table) (1)
//
// TOTAL ENUMS: 11
// - UserRole, AccountStatus, OTPType, OAuthProviderType
// - ProjectStatus, ProjectPriority, ProjectActivityType
// - ReportStatus
// - NotificationType, NotificationCategory, NotificationPriority
// - SystemLogType, SystemLogStatus
//
// ==========================================================================================


===== src/common/types/response.types.ts =====
// src/common/types/response.types.ts

// ============================================
// BASE TYPES
// ============================================

/**
 * Standard metadata included in all responses
 */
export interface IResponseMeta {
    timestamp: string;
    requestId: string;
    path: string;
}

// ============================================
// SUCCESS RESPONSE
// ============================================

/**
 * Standard success response structure
 */
export interface ISuccessResponse<T = any> {
    success: true;
    message?: string;
    data: T;
    meta: IResponseMeta;
}

// ============================================
// ERROR RESPONSE
// ============================================

/**
 * Standard error response structure
 */
export interface IErrorResponse {
    success: false;
    error: {
        code: string;
        message: string;
        statusCode: number;
        details?: any;
    };
    meta: IResponseMeta;
}

// ============================================
// WARNING RESPONSE
// ============================================

/**
 * Response with warning - operation succeeded but with non-critical issues
 */
export interface IWarningResponse<T = any> {
    success: true;
    data: T;
    warning: {
        code: string;
        message: string;
    };
    meta: IResponseMeta;
}

// ============================================
// INFO RESPONSE
// ============================================

/**
 * Response with informational message
 */
export interface IInfoResponse<T = any> {
    success: true;
    data: T;
    info: {
        code: string;
        message: string;
    };
    meta: IResponseMeta;
}

// ============================================
// VALIDATION ERROR
// ============================================

/**
 * Validation error details
 */
export interface IValidationError {
    field: string;
    message: string;
    value?: any;
    constraint?: string;
}

// ============================================
// PAGINATION METADATA
// ============================================

/**
 * Pagination metadata for list endpoints
 */
export interface IPaginationMeta {
    total: number;
    page: number;
    limit: number;
    totalPages: number;
    hasNextPage: boolean;
    hasPreviousPage: boolean;
}

/**
 * Paginated response data structure
 */
export interface IPaginatedData<T> {
    items: T[];
    pagination: IPaginationMeta;
}

// ============================================
// TYPE UNIONS
// ============================================

/**
 * Union of all possible response types
 */
export type ApiResponse<T = any> =
    | ISuccessResponse<T>
    | IErrorResponse
    | IWarningResponse<T>
    | IInfoResponse<T>;

// ============================================
// TYPE GUARDS
// ============================================

/**
 * Type guard to check if response is successful
 */
export function isSuccessResponse<T>(
    response: ApiResponse<T>
): response is ISuccessResponse<T> | IWarningResponse<T> | IInfoResponse<T> {
    return response.success === true;
}

/**
 * Type guard to check if response is an error
 */
export function isErrorResponse(
    response: ApiResponse
): response is IErrorResponse {
    return response.success === false;
}

/**
 * Type guard to check if response has a warning
 */
export function hasWarning<T>(
    response: ApiResponse<T>
): response is IWarningResponse<T> {
    return response.success === true && 'warning' in response;
}

/**
 * Type guard to check if response has info
 */
export function hasInfo<T>(
    response: ApiResponse<T>
): response is IInfoResponse<T> {
    return response.success === true && 'info' in response;
}


===== src/common/utils/response-builder.util.ts =====
// src/common/utils/response-builder.util.ts

import { Injectable } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { RequestContextService } from '@core/context/request-context.service';
import {
    ISuccessResponse,
    IErrorResponse,
    IWarningResponse,
    IInfoResponse,
    IResponseMeta,
    IPaginatedData,
    IPaginationMeta,
} from '@common/types/response.types';

/**
 * Response Builder Utility
 * 
 * Centralized utility for building standardized API responses
 * Automatically handles meta field based on environment configuration
 */
@Injectable()
export class ResponseBuilder {
    private readonly includeMeta: boolean;
    private readonly includeMetaInProduction: boolean;
    private readonly includeRequestId: boolean;
    private readonly includeTimestamp: boolean;
    private readonly includePath: boolean;

    constructor(
        private readonly configService: ConfigService,
        private readonly contextService: RequestContextService,
    ) {
        const nodeEnv = this.configService.get<string>('NODE_ENV', 'development');

        // Default: Include meta in dev/staging, exclude in production
        this.includeMetaInProduction = this.configService.get<string>('INCLUDE_META_IN_PRODUCTION', 'false') === 'true';
        this.includeMeta = nodeEnv !== 'production' || this.includeMetaInProduction;

        // Granular control over meta fields
        this.includeRequestId = this.configService.get<string>('INCLUDE_REQUEST_ID', 'true') === 'true';
        this.includeTimestamp = this.configService.get<string>('INCLUDE_TIMESTAMP', 'true') === 'true';
        this.includePath = this.configService.get<string>('INCLUDE_PATH', nodeEnv !== 'production' ? 'true' : 'false') === 'true';
    }

    // ============================================
    // META BUILDER
    // ============================================

    /**
     * Build meta object based on environment configuration
     * Returns undefined if meta should be excluded
     */
    private buildMeta(path?: string): IResponseMeta | undefined {
        if (!this.includeMeta) {
            return undefined;
        }

        const context = this.contextService.getContext();
        const meta: Partial<IResponseMeta> = {};

        if (this.includeTimestamp) {
            meta.timestamp = new Date().toISOString();
        }

        if (this.includeRequestId && context?.requestId) {
            meta.requestId = context.requestId;
        }

        if (this.includePath && path) {
            meta.path = path;
        }

        if (Object.keys(meta).length === 0) {
            return undefined;
        }

        return meta as IResponseMeta;
    }

    // ============================================
    // SUCCESS RESPONSES
    // ============================================

    /**
     * Build success response
     */
    success<T>(
        data: T,
        message?: string,
        path?: string,
    ): Omit<ISuccessResponse<T>, 'success'> {
        const meta = this.buildMeta(path);

        const response: any = {
            success: true,
            data,
        };

        if (message) {
            response.message = message;
        }

        if (meta) {
            response.meta = meta;
        }

        return response;
    }

    /**
     * Build paginated success response
     */
    paginated<T>(
        items: T[],
        pagination: IPaginationMeta,
        message?: string,
        path?: string,
    ): Omit<ISuccessResponse<IPaginatedData<T>>, 'success'> {
        const data: IPaginatedData<T> = {
            items,
            pagination,
        };

        return this.success(data, message, path);
    }

    // ============================================
    // WARNING RESPONSES
    // ============================================

    /**
     * Build warning response (success with non-critical issues)
     */
    warning<T>(
        data: T,
        warningCode: string,
        warningMessage: string,
        path?: string,
    ): Omit<IWarningResponse<T>, 'success'> {
        const meta = this.buildMeta(path);

        const response: any = {
            success: true,
            data,
            warning: {
                code: warningCode,
                message: warningMessage,
            },
        };

        if (meta) {
            response.meta = meta;
        }

        return response;
    }

    // ============================================
    // INFO RESPONSES
    // ============================================

    /**
     * Build info response (success with additional information)
     */
    info<T>(
        data: T,
        infoCode: string,
        infoMessage: string,
        path?: string,
    ): Omit<IInfoResponse<T>, 'success'> {
        const meta = this.buildMeta(path);

        const response: any = {
            success: true,
            data,
            info: {
                code: infoCode,
                message: infoMessage,
            },
        };

        if (meta) {
            response.meta = meta;
        }

        return response;
    }

    // ============================================
    // ERROR RESPONSES (Used by Exception Filters)
    // ============================================

    /**
     * Build error response
     */
    error(
        code: string,
        message: string,
        statusCode: number,
        path?: string,
        details?: any,
    ): Omit<IErrorResponse, 'success'> {
        const meta = this.buildMeta(path);

        const response: any = {
            success: false,
            error: {
                code,
                message,
                statusCode,
                ...(details && { details }),
            },
        };

        if (meta) {
            response.meta = meta;
        }

        return response;
    }

    // ============================================
    // HELPER METHODS
    // ============================================

    /**
     * Check if meta should be included in responses
     */
    shouldIncludeMeta(): boolean {
        return this.includeMeta;
    }

    /**
     * Get current environment
     */
    getEnvironment(): string {
        return this.configService.get<string>('NODE_ENV', 'development');
    }

    /**
     * Build pagination meta from query params
     */
    buildPaginationMeta(
        total: number,
        page: number,
        limit: number,
    ): IPaginationMeta {
        const totalPages = Math.ceil(total / limit);

        return {
            total,
            page,
            limit,
            totalPages,
            hasNextPage: page < totalPages,
            hasPreviousPage: page > 1,
        };
    }
}


===== src/core/filters/global-exception.filter.ts =====
// src/core/filters/global-exception.filter.ts

import {
    ExceptionFilter,
    Catch,
    ArgumentsHost,
    HttpException,
    HttpStatus,
} from '@nestjs/common';
import { Request, Response } from 'express';
import { AppLogger } from '@core/logger/logger.service';
import { RequestContextService } from '@core/context/request-context.service';
import { ResponseBuilder } from '@common/utils/response-builder.util';
import { ErrorCodes } from '@common/enums/error-codes.enum';

/**
 * Global Exception Filter
 * 
 * Catches ALL exceptions in the application and formats them into standardized error responses
 * Handles both HTTP exceptions and unexpected errors
 * Logs errors with context for debugging
 */
@Catch()
export class GlobalExceptionFilter implements ExceptionFilter {
    constructor(
        private readonly logger: AppLogger,
        private readonly contextService: RequestContextService,
        private readonly responseBuilder: ResponseBuilder,
    ) { }

    catch(exception: any, host: ArgumentsHost) {
        const ctx = host.switchToHttp();
        const response = ctx.getResponse<Response>();
        const request = ctx.getRequest<Request>();

        // Get request context
        const context = this.contextService.getContext();
        const requestId = context?.requestId || 'unknown';

        // Determine status code
        const status =
            exception instanceof HttpException
                ? exception.getStatus()
                : HttpStatus.INTERNAL_SERVER_ERROR;

        // Extract error details
        let errorCode: string;
        let errorMessage: string;
        let errorDetails: any = undefined;

        if (exception instanceof HttpException) {
            const exceptionResponse = exception.getResponse();

            if (typeof exceptionResponse === 'object') {
                const responseObj = exceptionResponse as any;
                errorCode = responseObj.code || this.getDefaultErrorCode(status);
                errorMessage = responseObj.message || exception.message;
                errorDetails = responseObj.details;
            } else {
                errorCode = this.getDefaultErrorCode(status);
                errorMessage = exceptionResponse as string;
            }
        } else {
            errorCode = ErrorCodes.INTERNAL_SERVER_ERROR;
            errorMessage = 'An unexpected error occurred. Please try again later.';
        }

        // Log error
        this.logger.error(
            `[${requestId}] ${request.method} ${request.url} - ${status} ${errorCode}: ${errorMessage}`,
            exception.stack,
            'GlobalExceptionFilter',
        );

        // Send standardized error response
        response.status(status).json(
            this.responseBuilder.error(
                errorCode,
                errorMessage,
                status,
                request.url,
                errorDetails,
            ),
        );
    }

    /**
     * Get default error code based on HTTP status
     */
    private getDefaultErrorCode(status: number): string {
        switch (status) {
            case HttpStatus.BAD_REQUEST:
                return ErrorCodes.BAD_REQUEST;
            case HttpStatus.UNAUTHORIZED:
                return ErrorCodes.UNAUTHORIZED;
            case HttpStatus.FORBIDDEN:
                return ErrorCodes.FORBIDDEN;
            case HttpStatus.NOT_FOUND:
                return ErrorCodes.NOT_FOUND;
            case HttpStatus.CONFLICT:
                return ErrorCodes.CONFLICT;
            case HttpStatus.INTERNAL_SERVER_ERROR:
                return ErrorCodes.INTERNAL_SERVER_ERROR;
            default:
                return 'UNKNOWN_ERROR';
        }
    }
}


